<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Wasmtime</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><a href="tutorial.html"><strong aria-hidden="true">2.</strong> Tutorial</a></li><li><ol class="section"><li><a href="tutorial-create-hello-world.html"><strong aria-hidden="true">2.1.</strong> Creating hello-world.wasm</a></li><li><a href="tutorial-run-hello-world.html"><strong aria-hidden="true">2.2.</strong> Running hello-world.wasm</a></li></ol></li><li><a href="examples.html"><strong aria-hidden="true">3.</strong> Examples</a></li><li><ol class="section"><li><a href="examples-markdown.html"><strong aria-hidden="true">3.1.</strong> Markdown Parser</a></li><li><a href="examples-profiling.html"><strong aria-hidden="true">3.2.</strong> Profiling WebAssembly</a></li><li><ol class="section"><li><a href="examples-profiling-perf.html"><strong aria-hidden="true">3.2.1.</strong> Profiling with Perf</a></li><li><a href="examples-profiling-vtune.html"><strong aria-hidden="true">3.2.2.</strong> Profiling with VTune</a></li></ol></li><li><a href="examples-rust-embed.html"><strong aria-hidden="true">3.3.</strong> Embedding in Rust</a></li><li><ol class="section"><li><a href="examples-rust-hello-world.html"><strong aria-hidden="true">3.3.1.</strong> Hello, world!</a></li><li><a href="examples-rust-gcd.html"><strong aria-hidden="true">3.3.2.</strong> Calculating the GCD</a></li><li><a href="examples-rust-memory.html"><strong aria-hidden="true">3.3.3.</strong> Using Linear Memory</a></li><li><a href="examples-rust-wasi.html"><strong aria-hidden="true">3.3.4.</strong> WASI</a></li><li><a href="examples-rust-linking.html"><strong aria-hidden="true">3.3.5.</strong> Linking Modules</a></li><li><a href="examples-rust-debugging.html"><strong aria-hidden="true">3.3.6.</strong> Debugging</a></li><li><a href="examples-rust-multi-value.html"><strong aria-hidden="true">3.3.7.</strong> Using Multi-Value</a></li></ol></li><li><a href="examples-c-embed.html"><strong aria-hidden="true">3.4.</strong> Embedding in C</a></li><li><ol class="section"><li><a href="examples-c-hello-world.html"><strong aria-hidden="true">3.4.1.</strong> Hello, World!</a></li><li><a href="examples-c-gcd.html"><strong aria-hidden="true">3.4.2.</strong> Calculating the GCD</a></li><li><a href="examples-c-memory.html"><strong aria-hidden="true">3.4.3.</strong> Using Linear Memory</a></li><li><a href="examples-c-wasi.html"><strong aria-hidden="true">3.4.4.</strong> WASI</a></li><li><a href="examples-c-linking.html"><strong aria-hidden="true">3.4.5.</strong> Linking Modules</a></li><li><a href="examples-c-debugging.html"><strong aria-hidden="true">3.4.6.</strong> Debugging</a></li><li><a href="examples-c-multi-value.html"><strong aria-hidden="true">3.4.7.</strong> Using Multi-Value</a></li></ol></li></ol></li><li><a href="lang.html"><strong aria-hidden="true">4.</strong> Using WebAssembly from your language</a></li><li><ol class="section"><li><a href="lang-rust.html"><strong aria-hidden="true">4.1.</strong> Rust</a></li><li><a href="lang-c.html"><strong aria-hidden="true">4.2.</strong> C</a></li><li><a href="lang-python.html"><strong aria-hidden="true">4.3.</strong> Python</a></li><li><a href="lang-dotnet.html"><strong aria-hidden="true">4.4.</strong> .NET</a></li><li><a href="lang-go.html"><strong aria-hidden="true">4.5.</strong> Go</a></li><li><a href="lang-bash.html"><strong aria-hidden="true">4.6.</strong> Bash</a></li></ol></li><li><a href="cli.html"><strong aria-hidden="true">5.</strong> Using the wasmtime CLI</a></li><li><ol class="section"><li><a href="cli-install.html"><strong aria-hidden="true">5.1.</strong> Installation</a></li><li><a href="cli-options.html"><strong aria-hidden="true">5.2.</strong> CLI Options</a></li><li><a href="cli-cache.html"><strong aria-hidden="true">5.3.</strong> Cache Configuration</a></li></ol></li><li><a href="wasm.html"><strong aria-hidden="true">6.</strong> Writing WebAssembly</a></li><li><ol class="section"><li><a href="wasm-rust.html"><strong aria-hidden="true">6.1.</strong> Rust</a></li><li><a href="wasm-c.html"><strong aria-hidden="true">6.2.</strong> C/C++</a></li><li><a href="wasm-assemblyscript.html"><strong aria-hidden="true">6.3.</strong> AssemblyScript</a></li><li><a href="wasm-wat.html"><strong aria-hidden="true">6.4.</strong> WebAssembly Text Format (*.wat)</a></li><li><a href="wasm-markdown.html"><strong aria-hidden="true">6.5.</strong> Example: Markdown Parser</a></li></ol></li><li><a href="stability.html"><strong aria-hidden="true">7.</strong> Stability</a></li><li><ol class="section"><li><a href="stability-release.html"><strong aria-hidden="true">7.1.</strong> Release Process</a></li><li><a href="stability-platform-support.html"><strong aria-hidden="true">7.2.</strong> Platform Support</a></li><li><a href="stability-wasm-proposals-support.html"><strong aria-hidden="true">7.3.</strong> Wasm Proposals Support</a></li></ol></li><li><a href="security.html"><strong aria-hidden="true">8.</strong> Security</a></li><li><ol class="section"><li><a href="security-disclosure.html"><strong aria-hidden="true">8.1.</strong> Disclosure Policy</a></li><li><a href="security-sandboxing.html"><strong aria-hidden="true">8.2.</strong> Sandboxing</a></li></ol></li><li><a href="contributing.html"><strong aria-hidden="true">9.</strong> Contributing</a></li><li><ol class="section"><li><a href="contributing-building.html"><strong aria-hidden="true">9.1.</strong> Building</a></li><li><a href="contributing-testing.html"><strong aria-hidden="true">9.2.</strong> Testing</a></li><li><a href="contributing-fuzzing.html"><strong aria-hidden="true">9.3.</strong> Fuzzing</a></li><li><a href="contributing-ci.html"><strong aria-hidden="true">9.4.</strong> CI</a></li><li><a href="contributing-coding-guidelines.html"><strong aria-hidden="true">9.5.</strong> Coding Guidelines</a></li><li><a href="contributing-development-process.html"><strong aria-hidden="true">9.6.</strong> Development Process</a></li><li><a href="contributing-release-process.html"><strong aria-hidden="true">9.7.</strong> Release Process</a></li><li><a href="contributing-implementing-wasm-proposals.html"><strong aria-hidden="true">9.8.</strong> Implementing Wasm Proposals</a></li><li><a href="contributing-governance.html"><strong aria-hidden="true">9.9.</strong> Governance</a></li><li><a href="contributing-coc.html"><strong aria-hidden="true">9.10.</strong> Code of Conduct</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Wasmtime</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p><a href="https://github.com/bytecodealliance/wasmtime">Wasmtime</a> is a <a href="https://bytecodealliance.org/">Bytecode Alliance</a> project that is a standalone
wasm-only optimizing runtime for <a href="https://webassembly.org/">WebAssembly</a> and <a href="https://wasi.dev">WASI</a>. It runs WebAssembly
code <a href="https://webassembly.org/docs/non-web/">outside of the Web</a>, and can be used both as a command-line utility or as
a library embedded in a larger application.</p>
<p>Wasmtime strives to be a highly configurable and embeddable runtime to run on
any scale of application. Many features are still under development so if you
have a question don't hesitate to <a href="https://github.com/bytecodealliance/wasmtime/issues/new">file an issue</a>.</p>
<p>This guide is intended to serve a number of purposes and within you'll find:</p>
<ul>
<li><a href="tutorial-create-hello-world.html">How to create simple wasm modules</a></li>
<li><a href="lang.html">How to use Wasmtime from a number of languages</a></li>
<li><a href="cli.html">How to install and use the <code>wasmtime</code> CLI</a></li>
<li>Information about <a href="stability.html">stability</a> and <a href="security.html">security</a> in
Wasmtime.</li>
</ul>
<p>... and more! The source for this guide <a href="https://github.com/bytecodealliance/wasmtime/tree/main/docs">lives on
GitHub</a> and
contributions are welcome!</p>
<h1><a class="header" href="#tutorial" id="tutorial">Tutorial</a></h1>
<p>This tutorial walks through creating a simple Hello World WebAssembly program
and then running it.</p>
<ul>
<li><a href="tutorial-create-hello-world.html">Creating <code>hello-world.wasm</code></a></li>
<li><a href="tutorial-run-hello-world.html">Running <code>hello-world.wasm</code></a></li>
</ul>
<h1><a class="header" href="#creating-hello-worldwasm" id="creating-hello-worldwasm">Creating <code>hello-world.wasm</code></a></h1>
<p>There are a number of ways to create <code>.wasm</code> files but for the purposes of this
tutorial, we'll be using the Rust toolchain. You can find more information on
creating <code>.wasm</code> files from other languages in the
<a href="./wasm.html">Writing WebAssembly section</a>.</p>
<p>To build WebAssembly binaries with Rust, you'll need the standard Rust toolchain.</p>
<p><a href="https://www.rust-lang.org/tools/install">Follow these instructions to install <code>rustc</code>, <code>rustup</code> and <code>cargo</code></a></p>
<p>Next, you should add WebAssembly as a build target for cargo like so:</p>
<pre><code class="language-sh">$ rustup target add wasm32-wasi
</code></pre>
<p>Finally, create a new Rust project called 'hello-world'. You can do this by running:</p>
<pre><code class="language-sh">$ cargo new hello-world
</code></pre>
<p>After that, the hello-world folder should look like this.</p>
<pre><code class="language-text">hello-world/
├── Cargo.lock
├── Cargo.toml
└── src
   └── main.rs
</code></pre>
<p>And the <code>main.rs</code> file inside the <code>src</code> folder should contain the following rust code.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}

</code></pre></pre>
<p>Now, we can tell <code>cargo</code> to build a WebAssembly file:</p>
<pre><code class="language-sh">$ cargo build --target wasm32-wasi
</code></pre>
<p>Now, in the <code>target</code> folder, there's a <code>hello-world.wasm</code> file. You can find it here:</p>
<pre><code class="language-text">hello-world/
├── Cargo.lock
├── Cargo.toml
├── src
└── target
   └── ...
   └── wasm32-wasi
      └── debug
         └── ...
         └── hello-world.wasm

</code></pre>
<h1><a class="header" href="#running-hello-worldwasm-with-wasmtime" id="running-hello-worldwasm-with-wasmtime">Running <code>hello-world.wasm</code> with Wasmtime</a></h1>
<h2><a class="header" href="#installing-wasmtime" id="installing-wasmtime">Installing Wasmtime</a></h2>
<p>The Wasmtime CLI can be installed on Linux and macOS with a small install
script:</p>
<pre><code class="language-sh">$ curl https://wasmtime.dev/install.sh -sSf | bash
</code></pre>
<p>You can find more information about installing the Wasmtime CLI in the
<a href="./cli-install.html">CLI Installation section</a></p>
<h2><a class="header" href="#running-hello-worldwasm" id="running-hello-worldwasm">Running <code>hello-world.wasm</code></a></h2>
<p>There are a number of ways to run a <code>.wasm</code> file with Wasmtime. In this
tutorial, we'll be using the CLI, Wasmtime can also be embedded in your
applications. More information on this can be found in the
<a href="./lang.html">Embedding Wasmtime section</a>.</p>
<p>If you've built the <code>hello-world.wasm</code> file (the instructions for doing so are in the
<a href="./tutorial-create-hello-world.html">previous section</a>),
you can run it with Wasmtime from the command line like so:</p>
<pre><code class="language-sh">$ wasmtime target/wasm32-wasi/debug/hello-world.wasm
</code></pre>
<h1><a class="header" href="#examples" id="examples">Examples</a></h1>
<p>This is an explanation of all examples to come</p>
<p>... more coming soon</p>
<h1><a class="header" href="#markdown-parser" id="markdown-parser">Markdown Parser</a></h1>
<p>... more coming soon</p>
<h1><a class="header" href="#profiling-webassembly" id="profiling-webassembly">Profiling WebAssembly</a></h1>
<p>One of WebAssembly's major goals is to be quite close to native code in terms of
performance, so typically when executing wasm you'll be quite interested in how
well your wasm module is performing! From time to time you might want to dive a
bit deeper into the performance of your wasm, and this is where profiling comes
into the picture.</p>
<p>Profiling support in Wasmtime is still under development, but if you're using either <a href="./examples-profiling-perf.html">perf</a> or <a href="./examples-profiling-vtune.html">Vtune</a> the examples in these sections are targeted at helping you get some information about the performance of your wasm modules.</p>
<h1><a class="header" href="#using-perf-on-linux" id="using-perf-on-linux">Using <code>perf</code> on Linux</a></h1>
<p>One profiler supported by Wasmtime is the <a href="https://perf.wiki.kernel.org/index.php/Main_Page"><code>perf</code>
profiler</a> for Linux. This is
an extremely powerful profiler with lots of documentation on the web, but for
the rest of this section we'll assume you're running on Linux and already have
<code>perf</code> installed.</p>
<p>Profiling support with <code>perf</code> uses the &quot;jitdump&quot; support in the <code>perf</code> CLI. This
requires runtime support from Wasmtime itself, so you will need to manually
change a few things to enable profiling support in your application. First
you'll want to make sure that Wasmtime is compiled with the <code>jitdump</code> Cargo
feature (which is enabled by default). Otherwise enabling runtime support
depends on how you're using Wasmtime:</p>
<ul>
<li>
<p><strong>Rust API</strong> - you'll want to call the [<code>Config::profiler</code>] method with
<code>ProfilingStrategy::JitDump</code> to enable profiling of your wasm modules.</p>
</li>
<li>
<p><strong>C API</strong> - you'll want to call the <code>wasmtime_config_profiler_set</code> API with a
<code>WASMTIME_PROFILING_STRATEGY_JITDUMP</code> value.</p>
</li>
<li>
<p><strong>Command Line</strong> - you'll want to pass the <code>--jitdump</code> flag on the command
line.</p>
</li>
</ul>
<p>Once jitdump support is enabled, you'll use <code>perf record</code> like usual to record
your application's performance. You'll need to also be sure to pass the
<code>--clockid mono</code> or <code>-k mono</code> flag to <code>perf record</code>.</p>
<p>For example if you're using the CLI, you'll execute:</p>
<pre><code class="language-sh">$ perf record -k mono wasmtime --jitdump foo.wasm
</code></pre>
<p>This will create a <code>perf.data</code> file as per usual, but it will <em>also</em> create a
<code>jit-XXXX.dump</code> file. This extra <code>*.dump</code> file is the jitdump file which is
specified by <code>perf</code> and Wasmtime generates at runtime.</p>
<p>The next thing you need to do is to merge the <code>*.dump</code> file into the
<code>perf.data</code> file, which you can do with the <code>perf inject</code> command:</p>
<pre><code class="language-sh">$ perf inject --jit --input perf.data --output perf.jit.data
</code></pre>
<p>This will read <code>perf.data</code>, automatically pick up the <code>*.dump</code> file that's
correct, and then create <code>perf.jit.data</code> which merges all the JIT information
together. This should also create a lot of <code>jitted-XXXX-N.so</code> files in the
current directory which are ELF images for all the JIT functions that were
created by Wasmtime.</p>
<p>After that you can explore the <code>perf.jit.data</code> profile as you usually would,
for example with:</p>
<pre><code class="language-sh">$ perf report --input perf.jit.data
</code></pre>
<p>You should be able to annotate wasm functions and see their raw assembly. You
should also see entries for wasm functions show up as one function and the
name of each function matches the debug name section in the wasm file.</p>
<p>Note that support for jitdump is still relatively new in Wasmtime, so if you
have any problems, please don't hesitate to <a href="https://github.com/bytecodealliance/wasmtime/issues/new">file an issue</a>!</p>
<h3><a class="header" href="#perf-and-dwarf-information" id="perf-and-dwarf-information"><code>perf</code> and DWARF information</a></h3>
<p>If the jitdump profile doesn't give you enough information by default, you can
also enable dwarf debug information to be generated for JIT code which should
give the <code>perf</code> profiler more information about what's being profiled. This can
include information like more desriptive function names, filenames, and line
numbers.</p>
<p>Enabling dwarf debug information for JIT code depends on how you're using
Wasmtime:</p>
<ul>
<li>
<p><strong>Rust API</strong> - you'll want to call the <a href="https://bytecodealliance.github.io/wasmtime/api/wasmtime/struct.Config.html#method.debug_info"><code>Config::debug_info</code></a> method.</p>
</li>
<li>
<p><strong>C API</strong> - you'll want to call the <code>wasmtime_config_debug_info_set</code> API.</p>
</li>
<li>
<p><strong>Command Line</strong> - you'll want to pass the <code>-g</code> flag on the command line.</p>
</li>
</ul>
<p>You shouldn't need to do anything else to get this information into <code>perf</code>. The
perf collection data should automatically pick up all this dwarf debug
information.</p>
<h3><a class="header" href="#perf-example" id="perf-example"><code>perf</code> example</a></h3>
<p>Let's run through a quick example with <code>perf</code> to get the feel for things. First
let's take a look at some wasm:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let n = 42;
    println!(&quot;fib({}) = {}&quot;, n, fib(n));
}

fn fib(n: u32) -&gt; u32 {
    if n &lt;= 2 {
        1
    } else {
        fib(n - 1) + fib(n - 2)
    }
}
</code></pre></pre>
<p>To collect perf information for this wasm module we'll execute:</p>
<pre><code class="language-sh">$ rustc --target wasm32-wasi fib.rs -O
$ perf record -k mono wasmtime --jitdump fib.wasm
fib(42) = 267914296
[ perf record: Woken up 1 times to write data ]
[ perf record: Captured and wrote 0.147 MB perf.data (3435 samples) ]
$ perf inject --jit --input perf.data --output perf.jit.data
</code></pre>
<p>And we should have all out information now! We can execute <code>perf report</code> for
example to see that 99% of our runtime (as expected) is spent in our <code>fib</code>
function. Note that the symbol has been demangled to <code>fib::fib</code> which is what
the Rust symbol is:</p>
<pre><code class="language-sh">$ perf report --input perf.jit.data
</code></pre>
<p><img src="assets/perf-report-fib.png" alt="perf report output" /></p>
<p>Alternatively we could also use <code>perf annotate</code> to take a look at the
disassembly of the <code>fib</code> function, seeing what the JIT generated:</p>
<pre><code class="language-sh">$ perf annotate --input perf.jit.data
</code></pre>
<p><img src="assets/perf-annotate-fib.png" alt="perf annotate output" /></p>
<h1><a class="header" href="#using-vtune-on-linux" id="using-vtune-on-linux">Using <code>VTune</code> on Linux</a></h1>
<p><a href="https://software.intel.com/en-us/vtune-help"><code>VTune Profiler</code></a> is a popular performance profiling tool that targets both 32-bit and 64-bit x86 architectures. The tool collects profiling data during runtime and then either through command line or gui, provides a variety of options for viewing and doing anaysis on that data. VTune Profiler is available in both commerical and free options. The free download version backed by a community forum for support, is available <a href="https://software.intel.com/en-us/vtune/choose-download#standalone"><code>here</code></a>. This version is appropriate for detailed analysis of your WASM program. Note for jit support, Wasmtime only supports VTune profiling on linux platforms but other platforms are expected to be enabled in the future.</p>
<p>VTune support in wasmtime is provided through the jit profiling APIs at <a href="https://github.com/intel/ittapi"><code>https://github.com/intel/ittapi</code></a>. These APIs are provided for code generators (or the runtimes that use them) to report jit activities. These APIs are implemented in a shared library (built from the same <a href="https://github.com/intel/ittapi"><code>ittapi</code></a> project) which wasmtime pulls in and links to when vtune support is specified through the <code>vtune</code> cargo feature flag. This feature is not enabled by default. When the VTune collector is run, it links to this same shared library to handle profiling request related to the reported jit activities. Specifically, Wasmtime pulls in the ittapi-rs system crate which provides the shared library and Rust interface to the jit profiling APIs.</p>
<p>For jit profiling with VTune Profiler, first you want to make sure the <code>vtune</code> feature is enabled. After that, enabling runtime support is based on how you are using Wasmtime:</p>
<ul>
<li>
<p><strong>Rust API</strong> - you'll want to call the [<code>Config::profiler</code>] method with
<code>ProfilingStrategy::VTune</code> to enable profiling of your wasm modules.</p>
</li>
<li>
<p><strong>C API</strong> - you'll want to call the <code>wasmtime_config_profiler_set</code> API with a
<code>WASMTIME_PROFILING_STRATEGY_VTUNE</code> value.</p>
</li>
<li>
<p><strong>Command Line</strong> - you'll want to pass the <code>--vtune</code> flag on the command
line.</p>
</li>
</ul>
<p>After profiling is complete, a results folder will hold profiling data that can then be read and analyzed with VTune.</p>
<p>Also note, VTune is capable of profiling a single process or system wide. As such, and like perf, VTune is plenty capable of profiling the wasmtime runtime itself without any added support. However, APIs <a href="https://github.com/intel/ittapi"><code>here</code></a> also support an interface for marking the start and stop of code regions for easy isolatation in the VTune Profiler. Support for these APIs are expected to be added in the future.</p>
<p>Take the following example: with VTune properly installed, if you're using the CLI you'll execute with:</p>
<pre><code class="language-sh">$ cargo build --features=vtune
$ amplxe-cl -run-pass-thru=--no-altstack -collect hotspots target/debug/wasmtime --vtune foo.wasm
</code></pre>
<p>This command tells the VTune collector (amplxe-cl) to collect hotspot profiling data on wasmtime that is executing foo.wasm. The --vtune flag enables VTune support in wasmtime so that the collector is also alerted to jit events that take place during runtime. The first time this is run, the result of the command is a results diretory r000hs/ which contains hotspot profiling data for wasmtime and the execution of foo.wasm. This data can then be read and displayed via the command line or via the VTune gui by importing the result.</p>
<h3><a class="header" href="#vtune-example" id="vtune-example"><code>VTune</code> example</a></h3>
<p>Running through a familiar algorithm, first we'll start with the following wasm:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let n = 45;
    println!(&quot;fib({}) = {}&quot;, n, fib(n));
}

fn fib(n: u32) -&gt; u32 {
    if n &lt;= 2 {
        1
    } else {
        fib(n - 1) + fib(n - 2)
    }
}
</code></pre></pre>
<p>Profiling data using vtune can be collected a number of ways and profiling data can be collected to focus
on certain types of analysis. Below we show a command line executable option using amplxe-cl, which is
installed and in our path, to help find hotspots in our wasm module. To collect  profiling information then,
we'll simply execute:</p>
<pre><code class="language-sh">$ rustc --target wasm32-wasi fib.rs -C opt-level=z -C lto=yes
$ amplxe-cl -run-pass-thru=--no-altstack -v -collect hotspots target/debug/wasmtime --vtune fib.wasm
fib(45) = 1134903170
amplxe: Collection stopped.
amplxe: Using result path /home/jlb6740/wasmtime/r000hs
amplxe: Executing actions  7 % Clearing the database
amplxe: The database has been cleared, elapsed time is 0.239 seconds.
amplxe: Executing actions 14 % Updating precomputed scalar metrics
amplxe: Raw data has been loaded to the database, elapsed time is 0.792 seconds.
amplxe: Executing actions 19 % Processing profile metrics and debug information
...
...
Top Hotspots
Function                                                                                      Module          CPU Time
--------------------------------------------------------------------------------------------  --------------  --------
h2bacf53cb3845acf                                                                             [Dynamic code]    3.480s
__memmove_avx_unaligned_erms                                                                  libc.so.6         0.222s
cranelift_codegen::ir::instructions::InstructionData::opcode::hee6f5b6a72fc684e               wasmtime          0.122s
core::ptr::slice_from_raw_parts::hc5cb6f1b39a0e7a1                                            wasmtime          0.066s
_$LT$usize$u20$as$u20$core..slice..SliceIndex$LT$$u5b$T$u5d$$GT$$GT$::get::h70c7f142eeeee8bd  wasmtime          0.066s
</code></pre>
<p>Note again, wasmtime must be built with the <code>vtune</code> feature flag enabled. From here you there are several options for further analysis. Below is an example view of the collected as seen in VTune's gui with it's many options.</p>
<p><img src="assets/vtune-gui-fib.png" alt="vtune report output" /></p>
<p>For more information on VTune and the analysis tools it provides see the docs <a href="https://software.intel.com/en-us/vtune-help"><code>here</code></a>.</p>
<h1><a class="header" href="#embedding-in-rust" id="embedding-in-rust">Embedding in Rust</a></h1>
<p>This section is intended to showcase the Rust embedding API for Wasmtime. This
is done through the <a href="https://crates.io/crates/wasmtime"><code>wasmtime</code> crate</a>. In
addition to browsing the following examples you can also browse the <a href="./embed-rust.html">specific
section on Rust embedding</a> or the <a href="https://docs.rs/wasmtime">full API
documentation</a>.</p>
<h1><a class="header" href="#hello-world" id="hello-world">Hello, world!</a></h1>
<p>You can also <a href="https://github.com/bytecodealliance/wasmtime/blob/main/examples/hello.rs">browse this source code online</a> and clone the wasmtime
repository to run the example locally.</p>
<p>This example shows off how to instantiate a simple wasm module and interact with
it.</p>
<h2><a class="header" href="#hellowat" id="hellowat"><code>hello.wat</code></a></h2>
<pre><code class="language-wat">(module
  (func $hello (import &quot;&quot; &quot;hello&quot;))
  (func (export &quot;run&quot;) (call $hello))
)

</code></pre>
<h2><a class="header" href="#hellors" id="hellors"><code>hello.rs</code></a></h2>
<pre><code class="language-rust ignore">//! Small example of how to instantiate a wasm module that imports one function,
//! showing how you can fill in host functionality for a wasm module.

// You can execute this example with `cargo run --example hello`

use anyhow::Result;
use wasmtime::*;

fn main() -&gt; Result&lt;()&gt; {
    // Configure the initial compilation environment, creating the global
    // `Store` structure. Note that you can also tweak configuration settings
    // with a `Config` and an `Engine` if desired.
    println!(&quot;Initializing...&quot;);
    let store = Store::default();

    // Compile the wasm binary into an in-memory instance of a `Module`.
    println!(&quot;Compiling module...&quot;);
    let module = Module::from_file(store.engine(), &quot;examples/hello.wat&quot;)?;

    // Here we handle the imports of the module, which in this case is our
    // `HelloCallback` type and its associated implementation of `Callback.
    println!(&quot;Creating callback...&quot;);
    let hello_func = Func::wrap(&amp;store, || {
        println!(&quot;Calling back...&quot;);
        println!(&quot;&gt; Hello World!&quot;);
    });

    // Once we've got that all set up we can then move to the instantiation
    // phase, pairing together a compiled module as well as a set of imports.
    // Note that this is where the wasm `start` function, if any, would run.
    println!(&quot;Instantiating module...&quot;);
    let imports = [hello_func.into()];
    let instance = Instance::new(&amp;store, &amp;module, &amp;imports)?;

    // Next we poke around a bit to extract the `run` function from the module.
    println!(&quot;Extracting export...&quot;);
    let run = instance
        .get_func(&quot;run&quot;)
        .ok_or(anyhow::format_err!(&quot;failed to find `run` function export&quot;))?
        .get0::&lt;()&gt;()?;

    // And last but not least we can call it!
    println!(&quot;Calling export...&quot;);
    run()?;

    println!(&quot;Done.&quot;);
    Ok(())
}

</code></pre>
<h1><a class="header" href="#calculating-the-gcd" id="calculating-the-gcd">Calculating the GCD</a></h1>
<p>You can also <a href="https://github.com/bytecodealliance/wasmtime/blob/main/examples/gcd.rs">browse this source code online</a> and clone the wasmtime
repository to run the example locally.</p>
<p>This example shows off how run a wasm program which calculates the GCD of two
numbers.</p>
<h2><a class="header" href="#gcdwat" id="gcdwat"><code>gcd.wat</code></a></h2>
<pre><code class="language-wat">(module
  (func $gcd (param i32 i32) (result i32)
    (local i32)
    block  ;; label = @1
      block  ;; label = @2
        local.get 0
        br_if 0 (;@2;)
        local.get 1
        local.set 2
        br 1 (;@1;)
      end
      loop  ;; label = @2
        local.get 1
        local.get 0
        local.tee 2
        i32.rem_u
        local.set 0
        local.get 2
        local.set 1
        local.get 0
        br_if 0 (;@2;)
      end
    end
    local.get 2
  )
  (export &quot;gcd&quot; (func $gcd))
)


</code></pre>
<h2><a class="header" href="#gcdrs" id="gcdrs"><code>gcd.rs</code></a></h2>
<pre><code class="language-rust ignore">//! Example of instantiating of the WebAssembly module and invoking its exported
//! function.

// You can execute this example with `cargo run --example gcd`

use anyhow::Result;
use wasmtime::*;

fn main() -&gt; Result&lt;()&gt; {
    // Load our WebAssembly (parsed WAT in our case), and then load it into a
    // `Module` which is attached to a `Store` cache. After we've got that we
    // can instantiate it.
    let store = Store::default();
    let module = Module::from_file(store.engine(), &quot;examples/gcd.wat&quot;)?;
    let instance = Instance::new(&amp;store, &amp;module, &amp;[])?;

    // Invoke `gcd` export
    let gcd = instance
        .get_func(&quot;gcd&quot;)
        .ok_or(anyhow::format_err!(&quot;failed to find `gcd` function export&quot;))?
        .get2::&lt;i32, i32, i32&gt;()?;

    println!(&quot;gcd(6, 27) = {}&quot;, gcd(6, 27)?);
    Ok(())
}

</code></pre>
<h1><a class="header" href="#using-linear-memory" id="using-linear-memory">Using linear memory</a></h1>
<p>You can also <a href="https://github.com/bytecodealliance/wasmtime/blob/main/examples/memory.rs">browse this source code online</a> and clone the wasmtime
repository to run the example locally.</p>
<p>This example shows off how to interact with wasm memory in a module. Be sure to
read the documentation for <a href="https://bytecodealliance.github.io/wasmtime/api/wasmtime/struct.Memory.html"><code>Memory</code></a> as well.</p>
<h2><a class="header" href="#memorywat" id="memorywat"><code>memory.wat</code></a></h2>
<pre><code class="language-wat">(module
  (memory (export &quot;memory&quot;) 2 3)

  (func (export &quot;size&quot;) (result i32) (memory.size))
  (func (export &quot;load&quot;) (param i32) (result i32)
    (i32.load8_s (local.get 0))
  )
  (func (export &quot;store&quot;) (param i32 i32)
    (i32.store8 (local.get 0) (local.get 1))
  )

  (data (i32.const 0x1000) &quot;\01\02\03\04&quot;)
)

</code></pre>
<h2><a class="header" href="#memoryrs" id="memoryrs"><code>memory.rs</code></a></h2>
<pre><code class="language-rust ignore">//! An example of how to interact with wasm memory.
//!
//! Here a small wasm module is used to show how memory is initialized, how to
//! read and write memory through the `Memory` object, and how wasm functions
//! can trap when dealing with out-of-bounds addresses.

// You can execute this example with `cargo run --example example`

use anyhow::Result;
use wasmtime::*;

fn main() -&gt; Result&lt;()&gt; {
    // Create our `Store` context and then compile a module and create an
    // instance from the compiled module all in one go.
    let wasmtime_store = Store::default();
    let module = Module::from_file(wasmtime_store.engine(), &quot;examples/memory.wat&quot;)?;
    let instance = Instance::new(&amp;wasmtime_store, &amp;module, &amp;[])?;

    // Load up our exports from the instance
    let memory = instance
        .get_memory(&quot;memory&quot;)
        .ok_or(anyhow::format_err!(&quot;failed to find `memory` export&quot;))?;
    let size = instance
        .get_func(&quot;size&quot;)
        .ok_or(anyhow::format_err!(&quot;failed to find `size` export&quot;))?
        .get0::&lt;i32&gt;()?;
    let load = instance
        .get_func(&quot;load&quot;)
        .ok_or(anyhow::format_err!(&quot;failed to find `load` export&quot;))?
        .get1::&lt;i32, i32&gt;()?;
    let store = instance
        .get_func(&quot;store&quot;)
        .ok_or(anyhow::format_err!(&quot;failed to find `store` export&quot;))?
        .get2::&lt;i32, i32, ()&gt;()?;

    // Note that these memory reads are *unsafe* due to unknown knowledge about
    // aliasing with wasm memory. For more information about the safety
    // guarantees here and how to use `Memory` safely, see the API
    // documentation.
    println!(&quot;Checking memory...&quot;);
    assert_eq!(memory.size(), 2);
    assert_eq!(memory.data_size(), 0x20000);
    unsafe {
        assert_eq!(memory.data_unchecked_mut()[0], 0);
        assert_eq!(memory.data_unchecked_mut()[0x1000], 1);
        assert_eq!(memory.data_unchecked_mut()[0x1003], 4);
    }

    assert_eq!(size()?, 2);
    assert_eq!(load(0)?, 0);
    assert_eq!(load(0x1000)?, 1);
    assert_eq!(load(0x1003)?, 4);
    assert_eq!(load(0x1ffff)?, 0);
    assert!(load(0x20000).is_err()); // out of bounds trap

    println!(&quot;Mutating memory...&quot;);
    unsafe {
        memory.data_unchecked_mut()[0x1003] = 5;
    }

    store(0x1002, 6)?;
    assert!(store(0x20000, 0).is_err()); // out of bounds trap

    unsafe {
        assert_eq!(memory.data_unchecked_mut()[0x1002], 6);
        assert_eq!(memory.data_unchecked_mut()[0x1003], 5);
    }
    assert_eq!(load(0x1002)?, 6);
    assert_eq!(load(0x1003)?, 5);

    // Grow memory.
    println!(&quot;Growing memory...&quot;);
    memory.grow(1)?;
    assert_eq!(memory.size(), 3);
    assert_eq!(memory.data_size(), 0x30000);

    assert_eq!(load(0x20000)?, 0);
    store(0x20000, 0)?;
    assert!(load(0x30000).is_err());
    assert!(store(0x30000, 0).is_err());

    assert!(memory.grow(1).is_err());
    assert!(memory.grow(0).is_ok());

    println!(&quot;Creating stand-alone memory...&quot;);
    let memorytype = MemoryType::new(Limits::new(5, Some(5)));
    let memory2 = Memory::new(&amp;wasmtime_store, memorytype);
    assert_eq!(memory2.size(), 5);
    assert!(memory2.grow(1).is_err());
    assert!(memory2.grow(0).is_ok());

    Ok(())
}

</code></pre>
<h1><a class="header" href="#wasi" id="wasi">WASI</a></h1>
<p>You can also <a href="https://github.com/bytecodealliance/wasmtime/blob/main/examples/wasi/main.rs">browse this source code online</a> and clone the wasmtime
repository to run the example locally.</p>
<p>This example shows off how to instantiate a wasm module using WASI imports.</p>
<h2><a class="header" href="#wasm-source-code" id="wasm-source-code">Wasm Source code</a></h2>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}

</code></pre></pre>
<h2><a class="header" href="#wasirs" id="wasirs"><code>wasi.rs</code></a></h2>
<pre><code class="language-rust ignore">//! Example of instantiating of instantiating a wasm module which uses WASI
//! imports.

// You can execute this example with `cargo run --example wasi`

use anyhow::Result;
use wasmtime::*;
use wasmtime_wasi::{Wasi, WasiCtx};

fn main() -&gt; Result&lt;()&gt; {
    tracing_subscriber::FmtSubscriber::builder()
        .with_env_filter(tracing_subscriber::EnvFilter::from_default_env())
        .with_ansi(true)
        .init();

    let store = Store::default();
    let mut linker = Linker::new(&amp;store);

    // Create an instance of `Wasi` which contains a `WasiCtx`. Note that
    // `WasiCtx` provides a number of ways to configure what the target program
    // will have access to.
    let wasi = Wasi::new(&amp;store, WasiCtx::new(std::env::args())?);
    wasi.add_to_linker(&amp;mut linker)?;

    // Instantiate our module with the imports we've created, and run it.
    let module = Module::from_file(store.engine(), &quot;target/wasm32-wasi/debug/wasi.wasm&quot;)?;
    linker.module(&quot;&quot;, &amp;module)?;
    linker.get_default(&quot;&quot;)?.get0::&lt;()&gt;()?()?;

    Ok(())
}

</code></pre>
<h1><a class="header" href="#linking-modules" id="linking-modules">Linking modules</a></h1>
<p>You can also <a href="https://github.com/bytecodealliance/wasmtime/blob/main/examples/linking.rs">browse this source code online</a> and clone the wasmtime
repository to run the example locally.</p>
<p>This example shows off how to compile and instantiate modules which link
together.</p>
<h2><a class="header" href="#linking1wat" id="linking1wat"><code>linking1.wat</code></a></h2>
<pre><code class="language-wat">(module
  (import &quot;linking2&quot; &quot;double&quot; (func $double (param i32) (result i32)))
  (import &quot;linking2&quot; &quot;log&quot; (func $log (param i32 i32)))
  (import &quot;linking2&quot; &quot;memory&quot; (memory 1))
  (import &quot;linking2&quot; &quot;memory_offset&quot; (global $offset i32))

  (func (export &quot;run&quot;)
    ;; Call into the other module to double our number, and we could print it
    ;; here but for now we just drop it
    i32.const 2
    call $double
    drop

    ;; Our `data` segment initialized our imported memory, so let's print the
    ;; string there now.
    global.get $offset
    i32.const 14
    call $log
  )

  (data (global.get $offset) &quot;Hello, world!\n&quot;)
)


</code></pre>
<h2><a class="header" href="#linking2wat" id="linking2wat"><code>linking2.wat</code></a></h2>
<pre><code class="language-wat">(module
  (type $fd_write_ty (func (param i32 i32 i32 i32) (result i32)))
  (import &quot;wasi_snapshot_preview1&quot; &quot;fd_write&quot; (func $fd_write (type $fd_write_ty)))

  (func (export &quot;double&quot;) (param i32) (result i32)
    local.get 0
    i32.const 2
    i32.mul
  )

  (func (export &quot;log&quot;) (param i32 i32)
    ;; store the pointer in the first iovec field
    i32.const 4
    local.get 0
    i32.store

    ;; store the length in the first iovec field
    i32.const 4
    local.get 1
    i32.store offset=4

    ;; call the `fd_write` import
    i32.const 1     ;; stdout fd
    i32.const 4     ;; iovs start
    i32.const 1     ;; number of iovs
    i32.const 0     ;; where to write nwritten bytes
    call $fd_write
    drop
  )

  (memory (export &quot;memory&quot;) 2)
  (global (export &quot;memory_offset&quot;) i32 (i32.const 65536))
)

</code></pre>
<h2><a class="header" href="#linkingrs" id="linkingrs"><code>linking.rs</code></a></h2>
<pre><code class="language-rust ignore">//! Example of instantiating two modules which link to each other.

// You can execute this example with `cargo run --example linking`

use anyhow::Result;
use wasmtime::*;
use wasmtime_wasi::{Wasi, WasiCtx};

fn main() -&gt; Result&lt;()&gt; {
    let engine = Engine::default();
    let store = Store::new(&amp;engine);

    // First set up our linker which is going to be linking modules together. We
    // want our linker to have wasi available, so we set that up here as well.
    let mut linker = Linker::new(&amp;store);
    let wasi = Wasi::new(&amp;store, WasiCtx::new(std::env::args())?);
    wasi.add_to_linker(&amp;mut linker)?;

    // Load and compile our two modules
    let linking1 = Module::from_file(&amp;engine, &quot;examples/linking1.wat&quot;)?;
    let linking2 = Module::from_file(&amp;engine, &quot;examples/linking2.wat&quot;)?;

    // Instantiate our first module which only uses WASI, then register that
    // instance with the linker since the next linking will use it.
    let linking2 = linker.instantiate(&amp;linking2)?;
    linker.instance(&quot;linking2&quot;, &amp;linking2)?;

    // And with that we can perform the final link and the execute the module.
    let linking1 = linker.instantiate(&amp;linking1)?;
    let run = linking1.get_func(&quot;run&quot;).unwrap();
    let run = run.get0::&lt;()&gt;()?;
    run()?;
    Ok(())
}

</code></pre>
<h1><a class="header" href="#debugging" id="debugging">Debugging</a></h1>
<p>You can also <a href="https://github.com/bytecodealliance/wasmtime/blob/main/examples/fib-debug/main.rs">browse this source code online</a> and clone the wasmtime
repository to run the example locally.</p>
<p>This example shows off how to set up a module for dynamic runtime debugging via
a native debugger like GDB or LLDB.</p>
<h2><a class="header" href="#mainrs" id="mainrs"><code>main.rs</code></a></h2>
<pre><code class="language-rust ignore">//! Example of enabling debuginfo for wasm code which allows interactive
//! debugging of the wasm code. When using recent versions of LLDB
//! you can debug this executable and set breakpoints in wasm code and look at
//! the rust source code as input.

// To execute this example you'll need to run two commands:
//
//      cargo build -p example-fib-debug-wasm --target wasm32-unknown-unknown
//      cargo run --example fib-debug

use anyhow::Result;
use wasmtime::*;

fn main() -&gt; Result&lt;()&gt; {
    // Load our previously compiled wasm file (built previously with Cargo) and
    // also ensure that we generate debuginfo so this executable can be
    // debugged in GDB.
    let engine = Engine::new(Config::new().debug_info(true));
    let store = Store::new(&amp;engine);
    let module = Module::from_file(&amp;engine, &quot;target/wasm32-unknown-unknown/debug/fib.wasm&quot;)?;
    let instance = Instance::new(&amp;store, &amp;module, &amp;[])?;

    // Invoke `fib` export
    let fib = instance
        .get_func(&quot;fib&quot;)
        .ok_or(anyhow::format_err!(&quot;failed to find `fib` function export&quot;))?
        .get1::&lt;i32, i32&gt;()?;
    println!(&quot;fib(6) = {}&quot;, fib(6)?);
    Ok(())
}

</code></pre>
<h1><a class="header" href="#using-multi-value" id="using-multi-value">Using multi-value</a></h1>
<p>You can also <a href="https://github.com/bytecodealliance/wasmtime/blob/main/examples/multi.rs">browse this source code online</a> and clone the wasmtime
repository to run the example locally.</p>
<p>This example shows off how to interact with a wasm module that uses multi-value
exports and imports.</p>
<h2><a class="header" href="#multiwat" id="multiwat"><code>multi.wat</code></a></h2>
<pre><code class="language-wat">(module
  (func $f (import &quot;&quot; &quot;f&quot;) (param i32 i64) (result i64 i32))

  (func $g (export &quot;g&quot;) (param i32 i64) (result i64 i32)
    (call $f (local.get 0) (local.get 1))
  )

  (func $round_trip_many
    (export &quot;round_trip_many&quot;)
    (param i64 i64 i64 i64 i64 i64 i64 i64 i64 i64)
    (result i64 i64 i64 i64 i64 i64 i64 i64 i64 i64)

    local.get 0
    local.get 1
    local.get 2
    local.get 3
    local.get 4
    local.get 5
    local.get 6
    local.get 7
    local.get 8
    local.get 9)
)

</code></pre>
<h2><a class="header" href="#multirs" id="multirs"><code>multi.rs</code></a></h2>
<pre><code class="language-rust ignore">//! This is an example of working with multi-value modules and dealing with
//! multi-value functions.
//!
//! Note that the `Func::wrap*` interfaces cannot be used to return multiple
//! values just yet, so we need to use the more dynamic `Func::new` and
//! `Func::call` methods.

// You can execute this example with `cargo run --example multi`

use anyhow::{format_err, Result};
use wasmtime::*;

fn main() -&gt; Result&lt;()&gt; {
    println!(&quot;Initializing...&quot;);
    let engine = Engine::default();
    let store = Store::new(&amp;engine);

    // Compile.
    println!(&quot;Compiling module...&quot;);
    let module = Module::from_file(&amp;engine, &quot;examples/multi.wat&quot;)?;

    // Create external print functions.
    println!(&quot;Creating callback...&quot;);
    let callback_type = FuncType::new(
        Box::new([ValType::I32, ValType::I64]),
        Box::new([ValType::I64, ValType::I32]),
    );
    let callback_func = Func::new(&amp;store, callback_type, |_, args, results| {
        println!(&quot;Calling back...&quot;);
        println!(&quot;&gt; {} {}&quot;, args[0].unwrap_i32(), args[1].unwrap_i64());

        results[0] = Val::I64(args[1].unwrap_i64() + 1);
        results[1] = Val::I32(args[0].unwrap_i32() + 1);
        Ok(())
    });

    // Instantiate.
    println!(&quot;Instantiating module...&quot;);
    let instance = Instance::new(&amp;store, &amp;module, &amp;[callback_func.into()])?;

    // Extract exports.
    println!(&quot;Extracting export...&quot;);
    let g = instance
        .get_func(&quot;g&quot;)
        .ok_or(format_err!(&quot;failed to find export `g`&quot;))?;

    // Call `$g`.
    println!(&quot;Calling export \&quot;g\&quot;...&quot;);
    let results = g.call(&amp;[Val::I32(1), Val::I64(3)])?;

    println!(&quot;Printing result...&quot;);
    println!(&quot;&gt; {} {}&quot;, results[0].unwrap_i64(), results[1].unwrap_i32());

    assert_eq!(results[0].unwrap_i64(), 4);
    assert_eq!(results[1].unwrap_i32(), 2);

    // Call `$round_trip_many`.
    println!(&quot;Calling export \&quot;round_trip_many\&quot;...&quot;);
    let round_trip_many = instance
        .get_func(&quot;round_trip_many&quot;)
        .ok_or(format_err!(&quot;failed to find export `round_trip_many`&quot;))?;
    let args = vec![
        Val::I64(0),
        Val::I64(1),
        Val::I64(2),
        Val::I64(3),
        Val::I64(4),
        Val::I64(5),
        Val::I64(6),
        Val::I64(7),
        Val::I64(8),
        Val::I64(9),
    ];
    let results = round_trip_many.call(&amp;args)?;

    println!(&quot;Printing result...&quot;);
    print!(&quot;&gt;&quot;);
    for r in results.iter() {
        print!(&quot; {}&quot;, r.unwrap_i64());
    }
    println!();

    assert_eq!(results.len(), 10);
    assert!(args
        .iter()
        .zip(results.iter())
        .all(|(a, r)| a.i64() == r.i64()));

    Ok(())
}

</code></pre>
<h1><a class="header" href="#embedding-in-c" id="embedding-in-c">Embedding in C</a></h1>
<p>This section is intended to showcase the C embedding API for Wasmtime. Full
reference documentation for the C API <a href="https://bytecodealliance.github.io/wasmtime/c-api/">can be found online</a></p>
<h1><a class="header" href="#hello-world-1" id="hello-world-1">Hello, world!</a></h1>
<p>You can also <a href="https://github.com/bytecodealliance/wasmtime/blob/main/examples/hello.c">browse this source code online</a> and clone the wasmtime
repository to run the example locally.</p>
<p>This example shows off how to instantiate a simple wasm module and interact with
it.</p>
<h2><a class="header" href="#hellowat-1" id="hellowat-1"><code>hello.wat</code></a></h2>
<pre><code class="language-wat">(module
  (func $hello (import &quot;&quot; &quot;hello&quot;))
  (func (export &quot;run&quot;) (call $hello))
)

</code></pre>
<h2><a class="header" href="#helloc" id="helloc"><code>hello.c</code></a></h2>
<pre><code class="language-c">/*
Example of instantiating of the WebAssembly module and invoking its exported
function.

You can compile and run this example on Linux with:

   cargo build --release -p wasmtime-c-api
   cc examples/hello.c \
       -I crates/c-api/include \
       -I crates/c-api/wasm-c-api/include \
       target/release/libwasmtime.a \
       -lpthread -ldl -lm \
       -o hello
   ./hello

Note that on Windows and macOS the command will be similar, but you'll need
to tweak the `-lpthread` and such annotations as well as the name of the
`libwasmtime.a` file on Windows.
*/

#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;wasm.h&gt;
#include &lt;wasmtime.h&gt;

static void exit_with_error(const char *message, wasmtime_error_t *error, wasm_trap_t *trap);

static wasm_trap_t* hello_callback(const wasm_val_t args[], wasm_val_t results[]) {
  printf(&quot;Calling back...\n&quot;);
  printf(&quot;&gt; Hello World!\n&quot;);
  return NULL;
}

int main() {
  int ret = 0;
  // Set up our compilation context. Note that we could also work with a
  // `wasm_config_t` here to configure what feature are enabled and various
  // compilation settings.
  printf(&quot;Initializing...\n&quot;);
  wasm_engine_t *engine = wasm_engine_new();
  assert(engine != NULL);

  // With an engine we can create a *store* which is a long-lived group of wasm
  // modules.
  wasm_store_t *store = wasm_store_new(engine);
  assert(store != NULL);

  // Read our input file, which in this case is a wasm text file.
  FILE* file = fopen(&quot;examples/hello.wat&quot;, &quot;r&quot;);
  assert(file != NULL);
  fseek(file, 0L, SEEK_END);
  size_t file_size = ftell(file);
  fseek(file, 0L, SEEK_SET);
  wasm_byte_vec_t wat;
  wasm_byte_vec_new_uninitialized(&amp;wat, file_size);
  assert(fread(wat.data, file_size, 1, file) == 1);
  fclose(file);

  // Parse the wat into the binary wasm format
  wasm_byte_vec_t wasm;
  wasmtime_error_t *error = wasmtime_wat2wasm(&amp;wat, &amp;wasm);
  if (error != NULL)
    exit_with_error(&quot;failed to parse wat&quot;, error, NULL);
  wasm_byte_vec_delete(&amp;wat);

  // Now that we've got our binary webassembly we can compile our module.
  printf(&quot;Compiling module...\n&quot;);
  wasm_module_t *module = NULL;
  error = wasmtime_module_new(engine, &amp;wasm, &amp;module);
  wasm_byte_vec_delete(&amp;wasm);
  if (error != NULL)
    exit_with_error(&quot;failed to compile module&quot;, error, NULL);

  // Next up we need to create the function that the wasm module imports. Here
  // we'll be hooking up a thunk function to the `hello_callback` native
  // function above.
  printf(&quot;Creating callback...\n&quot;);
  wasm_functype_t *hello_ty = wasm_functype_new_0_0();
  wasm_func_t *hello = wasm_func_new(store, hello_ty, hello_callback);

  // With our callback function we can now instantiate the compiled module,
  // giving us an instance we can then execute exports from. Note that
  // instantiation can trap due to execution of the `start` function, so we need
  // to handle that here too.
  printf(&quot;Instantiating module...\n&quot;);
  wasm_trap_t *trap = NULL;
  wasm_instance_t *instance = NULL;
  const wasm_extern_t *imports[] = { wasm_func_as_extern(hello) };
  error = wasmtime_instance_new(store, module, imports, 1, &amp;instance, &amp;trap);
  if (instance == NULL)
    exit_with_error(&quot;failed to instantiate&quot;, error, trap);

  // Lookup our `run` export function
  printf(&quot;Extracting export...\n&quot;);
  wasm_extern_vec_t externs;
  wasm_instance_exports(instance, &amp;externs);
  assert(externs.size == 1);
  wasm_func_t *run = wasm_extern_as_func(externs.data[0]);
  assert(run != NULL);

  // And call it!
  printf(&quot;Calling export...\n&quot;);
  error = wasmtime_func_call(run, NULL, 0, NULL, 0, &amp;trap);
  if (error != NULL || trap != NULL)
    exit_with_error(&quot;failed to call function&quot;, error, trap);

  // Clean up after ourselves at this point
  printf(&quot;All finished!\n&quot;);
  ret = 0;

  wasm_extern_vec_delete(&amp;externs);
  wasm_instance_delete(instance);
  wasm_module_delete(module);
  wasm_store_delete(store);
  wasm_engine_delete(engine);
  return ret;
}

static void exit_with_error(const char *message, wasmtime_error_t *error, wasm_trap_t *trap) {
  fprintf(stderr, &quot;error: %s\n&quot;, message);
  wasm_byte_vec_t error_message;
  if (error != NULL) {
    wasmtime_error_message(error, &amp;error_message);
    wasmtime_error_delete(error);
  } else {
    wasm_trap_message(trap, &amp;error_message);
    wasm_trap_delete(trap);
  }
  fprintf(stderr, &quot;%.*s\n&quot;, (int) error_message.size, error_message.data);
  wasm_byte_vec_delete(&amp;error_message);
  exit(1);
}

</code></pre>
<h1><a class="header" href="#calculating-the-gcd-1" id="calculating-the-gcd-1">Calculating the GCD</a></h1>
<p>You can also <a href="https://github.com/bytecodealliance/wasmtime/blob/main/examples/gcd.c">browse this source code online</a> and clone the wasmtime
repository to run the example locally.</p>
<p>This example shows off how run a wasm program which calculates the GCD of two
numbers.</p>
<h2><a class="header" href="#gcdwat-1" id="gcdwat-1"><code>gcd.wat</code></a></h2>
<pre><code class="language-wat">(module
  (func $gcd (param i32 i32) (result i32)
    (local i32)
    block  ;; label = @1
      block  ;; label = @2
        local.get 0
        br_if 0 (;@2;)
        local.get 1
        local.set 2
        br 1 (;@1;)
      end
      loop  ;; label = @2
        local.get 1
        local.get 0
        local.tee 2
        i32.rem_u
        local.set 0
        local.get 2
        local.set 1
        local.get 0
        br_if 0 (;@2;)
      end
    end
    local.get 2
  )
  (export &quot;gcd&quot; (func $gcd))
)


</code></pre>
<h2><a class="header" href="#gcdc" id="gcdc"><code>gcd.c</code></a></h2>
<pre><code class="language-c">/*
Example of instantiating of the WebAssembly module and invoking its exported
function.

You can compile and run this example on Linux with:

   cargo build --release -p wasmtime-c-api
   cc examples/gcd.c \
       -I crates/c-api/include \
       -I crates/c-api/wasm-c-api/include \
       target/release/libwasmtime.a \
       -lpthread -ldl -lm \
       -o gcd
   ./gcd

Note that on Windows and macOS the command will be similar, but you'll need
to tweak the `-lpthread` and such annotations.
*/

#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;wasm.h&gt;
#include &lt;wasmtime.h&gt;

static void exit_with_error(const char *message, wasmtime_error_t *error, wasm_trap_t *trap);

int main() {
  int ret = 0;
  // Set up our context
  wasm_engine_t *engine = wasm_engine_new();
  assert(engine != NULL);
  wasm_store_t *store = wasm_store_new(engine);
  assert(store != NULL);

  // Load our input file to parse it next
  FILE* file = fopen(&quot;examples/gcd.wat&quot;, &quot;r&quot;);
  if (!file) {
    printf(&quot;&gt; Error loading file!\n&quot;);
    return 1;
  }
  fseek(file, 0L, SEEK_END);
  size_t file_size = ftell(file);
  fseek(file, 0L, SEEK_SET);
  wasm_byte_vec_t wat;
  wasm_byte_vec_new_uninitialized(&amp;wat, file_size);
  if (fread(wat.data, file_size, 1, file) != 1) {
    printf(&quot;&gt; Error loading module!\n&quot;);
    return 1;
  }
  fclose(file);

  // Parse the wat into the binary wasm format
  wasm_byte_vec_t wasm;
  wasmtime_error_t *error = wasmtime_wat2wasm(&amp;wat, &amp;wasm);
  if (error != NULL)
    exit_with_error(&quot;failed to parse wat&quot;, error, NULL);
  wasm_byte_vec_delete(&amp;wat);

  // Compile and instantiate our module
  wasm_module_t *module = NULL;
  error = wasmtime_module_new(engine, &amp;wasm, &amp;module);
  if (module == NULL)
    exit_with_error(&quot;failed to compile module&quot;, error, NULL);
  wasm_byte_vec_delete(&amp;wasm);
  wasm_trap_t *trap = NULL;
  wasm_instance_t *instance = NULL;
  error = wasmtime_instance_new(store, module, NULL, 0, &amp;instance, &amp;trap);
  if (instance == NULL)
    exit_with_error(&quot;failed to instantiate&quot;, error, trap);

  // Lookup our `gcd` export function
  wasm_extern_vec_t externs;
  wasm_instance_exports(instance, &amp;externs);
  assert(externs.size == 1);
  wasm_func_t *gcd = wasm_extern_as_func(externs.data[0]);
  assert(gcd != NULL);

  // And call it!
  int a = 6;
  int b = 27;
  wasm_val_t params[2];
  wasm_val_t results[1];
  params[0].kind = WASM_I32;
  params[0].of.i32 = a;
  params[1].kind = WASM_I32;
  params[1].of.i32 = b;
  error = wasmtime_func_call(gcd, params, 2, results, 1, &amp;trap);
  if (error != NULL || trap != NULL)
    exit_with_error(&quot;failed to call gcd&quot;, error, trap);
  assert(results[0].kind == WASM_I32);

  printf(&quot;gcd(%d, %d) = %d\n&quot;, a, b, results[0].of.i32);

  // Clean up after ourselves at this point
  ret = 0;

  wasm_extern_vec_delete(&amp;externs);
  wasm_instance_delete(instance);
  wasm_module_delete(module);
  wasm_store_delete(store);
  wasm_engine_delete(engine);
  return ret;
}

static void exit_with_error(const char *message, wasmtime_error_t *error, wasm_trap_t *trap) {
  fprintf(stderr, &quot;error: %s\n&quot;, message);
  wasm_byte_vec_t error_message;
  if (error != NULL) {
    wasmtime_error_message(error, &amp;error_message);
  } else {
    wasm_trap_message(trap, &amp;error_message);
  }
  fprintf(stderr, &quot;%.*s\n&quot;, (int) error_message.size, error_message.data);
  wasm_byte_vec_delete(&amp;error_message);
  exit(1);
}

</code></pre>
<h1><a class="header" href="#using-linear-memory-1" id="using-linear-memory-1">Using linear memory</a></h1>
<p>You can also <a href="https://github.com/bytecodealliance/wasmtime/blob/main/examples/memory.c">browse this source code online</a> and clone the wasmtime
repository to run the example locally.</p>
<p>This example shows off how to interact with wasm memory in a module. Be sure to
read the documentation for <a href="https://bytecodealliance.github.io/wasmtime/api/wasmtime/struct.Memory.html"><code>Memory</code></a> as well.</p>
<h2><a class="header" href="#memorywat-1" id="memorywat-1"><code>memory.wat</code></a></h2>
<pre><code class="language-wat">(module
  (memory (export &quot;memory&quot;) 2 3)

  (func (export &quot;size&quot;) (result i32) (memory.size))
  (func (export &quot;load&quot;) (param i32) (result i32)
    (i32.load8_s (local.get 0))
  )
  (func (export &quot;store&quot;) (param i32 i32)
    (i32.store8 (local.get 0) (local.get 1))
  )

  (data (i32.const 0x1000) &quot;\01\02\03\04&quot;)
)

</code></pre>
<h2><a class="header" href="#memoryc" id="memoryc"><code>memory.c</code></a></h2>
<pre><code class="language-c">/*
Example of instantiating of the WebAssembly module and invoking its exported
function.

You can compile and run this example on Linux with:

   cargo build --release -p wasmtime-c-api
   cc examples/memory.c \
       -I crates/c-api/include \
       -I crates/c-api/wasm-c-api/include \
       target/release/libwasmtime.a \
       -lpthread -ldl -lm \
       -o memory
   ./memory

Note that on Windows and macOS the command will be similar, but you'll need
to tweak the `-lpthread` and such annotations.

Also note that this example was taken from
https://github.com/WebAssembly/wasm-c-api/blob/master/example/memory.c
originally
*/

#include &lt;inttypes.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;wasm.h&gt;
#include &lt;wasmtime.h&gt;

static void exit_with_error(const char *message, wasmtime_error_t *error, wasm_trap_t *trap);

wasm_memory_t* get_export_memory(const wasm_extern_vec_t* exports, size_t i) {
  if (exports-&gt;size &lt;= i || !wasm_extern_as_memory(exports-&gt;data[i])) {
    printf(&quot;&gt; Error accessing memory export %zu!\n&quot;, i);
    exit(1);
  }
  return wasm_extern_as_memory(exports-&gt;data[i]);
}

wasm_func_t* get_export_func(const wasm_extern_vec_t* exports, size_t i) {
  if (exports-&gt;size &lt;= i || !wasm_extern_as_func(exports-&gt;data[i])) {
    printf(&quot;&gt; Error accessing function export %zu!\n&quot;, i);
    exit(1);
  }
  return wasm_extern_as_func(exports-&gt;data[i]);
}


void check(bool success) {
  if (!success) {
    printf(&quot;&gt; Error, expected success\n&quot;);
    exit(1);
  }
}

void check_call(wasm_func_t* func, wasm_val_t args[], size_t num_args, int32_t expected) {
  wasm_val_t results[1];
  wasm_trap_t *trap = NULL;
  wasmtime_error_t *error = wasmtime_func_call(func, args, num_args, results, 1, &amp;trap);
  if (error != NULL || trap != NULL)
    exit_with_error(&quot;failed to call function&quot;, error, trap);
  if (results[0].of.i32 != expected) {
    printf(&quot;&gt; Error on result\n&quot;);
    exit(1);
  }
}

void check_call0(wasm_func_t* func, int32_t expected) {
  check_call(func, NULL, 0, expected);
}

void check_call1(wasm_func_t* func, int32_t arg, int32_t expected) {
  wasm_val_t args[] = { {.kind = WASM_I32, .of = {.i32 = arg}} };
  check_call(func, args, 1, expected);
}

void check_call2(wasm_func_t* func, int32_t arg1, int32_t arg2, int32_t expected) {
  wasm_val_t args[2] = {
    {.kind = WASM_I32, .of = {.i32 = arg1}},
    {.kind = WASM_I32, .of = {.i32 = arg2}}
  };
  check_call(func, args, 2, expected);
}

void check_ok(wasm_func_t* func, wasm_val_t args[], size_t num_args) {
  wasm_trap_t *trap = NULL;
  wasmtime_error_t *error = wasmtime_func_call(func, args, num_args, NULL, 0, &amp;trap);
  if (error != NULL || trap != NULL)
    exit_with_error(&quot;failed to call function&quot;, error, trap);
}

void check_ok2(wasm_func_t* func, int32_t arg1, int32_t arg2) {
  wasm_val_t args[2] = {
    {.kind = WASM_I32, .of = {.i32 = arg1}},
    {.kind = WASM_I32, .of = {.i32 = arg2}}
  };
  check_ok(func, args, 2);
}

void check_trap(wasm_func_t* func, wasm_val_t args[], size_t num_args, size_t num_results) {
  wasm_val_t results[1];
  assert(num_results &lt;= 1);
  wasm_trap_t *trap = NULL;
  wasmtime_error_t *error = wasmtime_func_call(func, args, num_args, results, num_results, &amp;trap);
  if (error != NULL)
    exit_with_error(&quot;failed to call function&quot;, error, NULL);
  if (trap == NULL) {
    printf(&quot;&gt; Error on result, expected trap\n&quot;);
    exit(1);
  }
  wasm_trap_delete(trap);
}

void check_trap1(wasm_func_t* func, int32_t arg) {
  wasm_val_t args[1] = { {.kind = WASM_I32, .of = {.i32 = arg}} };
  check_trap(func, args, 1, 1);
}

void check_trap2(wasm_func_t* func, int32_t arg1, int32_t arg2) {
  wasm_val_t args[2] = {
    {.kind = WASM_I32, .of = {.i32 = arg1}},
    {.kind = WASM_I32, .of = {.i32 = arg2}}
  };
  check_trap(func, args, 2, 0);
}

int main(int argc, const char* argv[]) {
  // Initialize.
  printf(&quot;Initializing...\n&quot;);
  wasm_engine_t* engine = wasm_engine_new();
  wasm_store_t* store = wasm_store_new(engine);

  // Load our input file to parse it next
  FILE* file = fopen(&quot;examples/memory.wat&quot;, &quot;r&quot;);
  if (!file) {
    printf(&quot;&gt; Error loading file!\n&quot;);
    return 1;
  }
  fseek(file, 0L, SEEK_END);
  size_t file_size = ftell(file);
  fseek(file, 0L, SEEK_SET);
  wasm_byte_vec_t wat;
  wasm_byte_vec_new_uninitialized(&amp;wat, file_size);
  if (fread(wat.data, file_size, 1, file) != 1) {
    printf(&quot;&gt; Error loading module!\n&quot;);
    return 1;
  }
  fclose(file);

  // Parse the wat into the binary wasm format
  wasm_byte_vec_t binary;
  wasmtime_error_t *error = wasmtime_wat2wasm(&amp;wat, &amp;binary);
  if (error != NULL)
    exit_with_error(&quot;failed to parse wat&quot;, error, NULL);
  wasm_byte_vec_delete(&amp;wat);

  // Compile.
  printf(&quot;Compiling module...\n&quot;);
  wasm_module_t* module = NULL;
  error = wasmtime_module_new(engine, &amp;binary, &amp;module);
  if (error)
    exit_with_error(&quot;failed to compile module&quot;, error, NULL);
  wasm_byte_vec_delete(&amp;binary);

  // Instantiate.
  printf(&quot;Instantiating module...\n&quot;);
  wasm_instance_t* instance = NULL;
  wasm_trap_t *trap = NULL;
  error = wasmtime_instance_new(store, module, NULL, 0, &amp;instance, &amp;trap);
  if (!instance)
    exit_with_error(&quot;failed to instantiate&quot;, error, trap);

  // Extract export.
  printf(&quot;Extracting exports...\n&quot;);
  wasm_extern_vec_t exports;
  wasm_instance_exports(instance, &amp;exports);
  size_t i = 0;
  wasm_memory_t* memory = get_export_memory(&amp;exports, i++);
  wasm_func_t* size_func = get_export_func(&amp;exports, i++);
  wasm_func_t* load_func = get_export_func(&amp;exports, i++);
  wasm_func_t* store_func = get_export_func(&amp;exports, i++);

  wasm_module_delete(module);

  // Try cloning.
  wasm_memory_t* copy = wasm_memory_copy(memory);
  wasm_memory_delete(copy);

  // Check initial memory.
  printf(&quot;Checking memory...\n&quot;);
  check(wasm_memory_size(memory) == 2);
  check(wasm_memory_data_size(memory) == 0x20000);
  check(wasm_memory_data(memory)[0] == 0);
  check(wasm_memory_data(memory)[0x1000] == 1);
  check(wasm_memory_data(memory)[0x1003] == 4);

  check_call0(size_func, 2);
  check_call1(load_func, 0, 0);
  check_call1(load_func, 0x1000, 1);
  check_call1(load_func, 0x1003, 4);
  check_call1(load_func, 0x1ffff, 0);
  check_trap1(load_func, 0x20000);

  // Mutate memory.
  printf(&quot;Mutating memory...\n&quot;);
  wasm_memory_data(memory)[0x1003] = 5;
  check_ok2(store_func, 0x1002, 6);
  check_trap2(store_func, 0x20000, 0);

  check(wasm_memory_data(memory)[0x1002] == 6);
  check(wasm_memory_data(memory)[0x1003] == 5);
  check_call1(load_func, 0x1002, 6);
  check_call1(load_func, 0x1003, 5);

  // Grow memory.
  printf(&quot;Growing memory...\n&quot;);
  check(wasm_memory_grow(memory, 1));
  check(wasm_memory_size(memory) == 3);
  check(wasm_memory_data_size(memory) == 0x30000);

  check_call1(load_func, 0x20000, 0);
  check_ok2(store_func, 0x20000, 0);
  check_trap1(load_func, 0x30000);
  check_trap2(store_func, 0x30000, 0);

  check(! wasm_memory_grow(memory, 1));
  check(wasm_memory_grow(memory, 0));

  wasm_extern_vec_delete(&amp;exports);
  wasm_instance_delete(instance);

  // Create stand-alone memory.
  printf(&quot;Creating stand-alone memory...\n&quot;);
  wasm_limits_t limits = {5, 5};
  wasm_memorytype_t* memorytype = wasm_memorytype_new(&amp;limits);
  wasm_memory_t* memory2 = wasm_memory_new(store, memorytype);
  check(wasm_memory_size(memory2) == 5);
  check(! wasm_memory_grow(memory2, 1));
  check(wasm_memory_grow(memory2, 0));

  wasm_memorytype_delete(memorytype);
  wasm_memory_delete(memory2);

  // Shut down.
  printf(&quot;Shutting down...\n&quot;);
  wasm_store_delete(store);
  wasm_engine_delete(engine);

  // All done.
  printf(&quot;Done.\n&quot;);
  return 0;
}

static void exit_with_error(const char *message, wasmtime_error_t *error, wasm_trap_t *trap) {
  fprintf(stderr, &quot;error: %s\n&quot;, message);
  wasm_byte_vec_t error_message;
  if (error != NULL) {
    wasmtime_error_message(error, &amp;error_message);
    wasmtime_error_delete(error);
  } else {
    wasm_trap_message(trap, &amp;error_message);
    wasm_trap_delete(trap);
  }
  fprintf(stderr, &quot;%.*s\n&quot;, (int) error_message.size, error_message.data);
  wasm_byte_vec_delete(&amp;error_message);
  exit(1);
}

</code></pre>
<h1><a class="header" href="#wasi-1" id="wasi-1">WASI</a></h1>
<p>You can also <a href="https://github.com/bytecodealliance/wasmtime/blob/main/examples/wasi/main.c">browse this source code online</a> and clone the wasmtime
repository to run the example locally.</p>
<p>This example shows off how to instantiate a wasm module using WASI imports.</p>
<h2><a class="header" href="#wasm-source-code-1" id="wasm-source-code-1">Wasm Source code</a></h2>
<pre><code class="language-rust ignore">fn main() {
    println!(&quot;Hello, world!&quot;);
}

</code></pre>
<h2><a class="header" href="#wasic" id="wasic"><code>wasi.c</code></a></h2>
<pre><code class="language-c">/*
Example of instantiating a WebAssembly which uses WASI imports.

You can compile and run this example on Linux with:

   cargo build --release -p wasmtime-c-api
   cc examples/wasi/main.c \
       -I crates/c-api/include \
       -I crates/c-api/wasm-c-api/include \
       target/release/libwasmtime.a \
       -lpthread -ldl -lm \
       -o wasi
   ./wasi

Note that on Windows and macOS the command will be similar, but you'll need
to tweak the `-lpthread` and such annotations.
*/

#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;wasm.h&gt;
#include &lt;wasi.h&gt;
#include &lt;wasmtime.h&gt;

#define MIN(a, b) ((a) &lt; (b) ? (a) : (b))

static void exit_with_error(const char *message, wasmtime_error_t *error, wasm_trap_t *trap);

int main() {
  int ret = 0;
  // Set up our context
  wasm_engine_t *engine = wasm_engine_new();
  assert(engine != NULL);
  wasm_store_t *store = wasm_store_new(engine);
  assert(store != NULL);

  wasm_byte_vec_t wasm;
  // Load our input file to parse it next
  FILE* file = fopen(&quot;target/wasm32-wasi/debug/wasi.wasm&quot;, &quot;rb&quot;);
  if (!file) {
    printf(&quot;&gt; Error loading file!\n&quot;);
    exit(1);
  }
  fseek(file, 0L, SEEK_END);
  size_t file_size = ftell(file);
  wasm_byte_vec_new_uninitialized(&amp;wasm, file_size);
  fseek(file, 0L, SEEK_SET);
  if (fread(wasm.data, file_size, 1, file) != 1) {
    printf(&quot;&gt; Error loading module!\n&quot;);
    exit(1);
  }
  fclose(file);

  // Compile our modules
  wasm_module_t *module = NULL;
  wasmtime_error_t *error = wasmtime_module_new(engine, &amp;wasm, &amp;module);
  if (!module)
    exit_with_error(&quot;failed to compile module&quot;, error, NULL);
  wasm_byte_vec_delete(&amp;wasm);

  // Instantiate wasi
  wasi_config_t *wasi_config = wasi_config_new();
  assert(wasi_config);
  wasi_config_inherit_argv(wasi_config);
  wasi_config_inherit_env(wasi_config);
  wasi_config_inherit_stdin(wasi_config);
  wasi_config_inherit_stdout(wasi_config);
  wasi_config_inherit_stderr(wasi_config);
  wasm_trap_t *trap = NULL;
  wasi_instance_t *wasi = wasi_instance_new(store, &quot;wasi_snapshot_preview1&quot;, wasi_config, &amp;trap);
  if (wasi == NULL)
    exit_with_error(&quot;failed to instantiate WASI&quot;, NULL, trap);

  wasmtime_linker_t *linker = wasmtime_linker_new(store);
  error = wasmtime_linker_define_wasi(linker, wasi);
  if (error != NULL)
    exit_with_error(&quot;failed to link wasi&quot;, error, NULL);

  // Instantiate the module
  wasm_name_t empty;
  wasm_name_new_from_string(&amp;empty, &quot;&quot;);
  wasm_instance_t *instance = NULL;
  error = wasmtime_linker_module(linker, &amp;empty, module);
  if (error != NULL)
    exit_with_error(&quot;failed to instantiate module&quot;, error, NULL);

  // Run it.
  wasm_func_t* func;
  wasmtime_linker_get_default(linker, &amp;empty, &amp;func);
  if (error != NULL)
    exit_with_error(&quot;failed to locate default export for module&quot;, error, NULL);
  error = wasmtime_func_call(func, NULL, 0, NULL, 0, &amp;trap);
  if (error != NULL)
    exit_with_error(&quot;error calling default export&quot;, error, trap);

  // Clean up after ourselves at this point
  wasm_name_delete(&amp;empty);
  wasm_module_delete(module);
  wasm_store_delete(store);
  wasm_engine_delete(engine);
  return 0;
}

static void exit_with_error(const char *message, wasmtime_error_t *error, wasm_trap_t *trap) {
  fprintf(stderr, &quot;error: %s\n&quot;, message);
  wasm_byte_vec_t error_message;
  if (error != NULL) {
    wasmtime_error_message(error, &amp;error_message);
    wasmtime_error_delete(error);
  } else {
    wasm_trap_message(trap, &amp;error_message);
    wasm_trap_delete(trap);
  }
  fprintf(stderr, &quot;%.*s\n&quot;, (int) error_message.size, error_message.data);
  wasm_byte_vec_delete(&amp;error_message);
  exit(1);
}

</code></pre>
<h1><a class="header" href="#linking-modules-1" id="linking-modules-1">Linking modules</a></h1>
<p>You can also <a href="https://github.com/bytecodealliance/wasmtime/blob/main/examples/linking.c">browse this source code online</a> and clone the wasmtime
repository to run the example locally.</p>
<p>This example shows off how to compile and instantiate modules which link
together.</p>
<h2><a class="header" href="#linking1wat-1" id="linking1wat-1"><code>linking1.wat</code></a></h2>
<pre><code class="language-wat">(module
  (import &quot;linking2&quot; &quot;double&quot; (func $double (param i32) (result i32)))
  (import &quot;linking2&quot; &quot;log&quot; (func $log (param i32 i32)))
  (import &quot;linking2&quot; &quot;memory&quot; (memory 1))
  (import &quot;linking2&quot; &quot;memory_offset&quot; (global $offset i32))

  (func (export &quot;run&quot;)
    ;; Call into the other module to double our number, and we could print it
    ;; here but for now we just drop it
    i32.const 2
    call $double
    drop

    ;; Our `data` segment initialized our imported memory, so let's print the
    ;; string there now.
    global.get $offset
    i32.const 14
    call $log
  )

  (data (global.get $offset) &quot;Hello, world!\n&quot;)
)


</code></pre>
<h2><a class="header" href="#linking2wat-1" id="linking2wat-1"><code>linking2.wat</code></a></h2>
<pre><code class="language-wat">(module
  (type $fd_write_ty (func (param i32 i32 i32 i32) (result i32)))
  (import &quot;wasi_snapshot_preview1&quot; &quot;fd_write&quot; (func $fd_write (type $fd_write_ty)))

  (func (export &quot;double&quot;) (param i32) (result i32)
    local.get 0
    i32.const 2
    i32.mul
  )

  (func (export &quot;log&quot;) (param i32 i32)
    ;; store the pointer in the first iovec field
    i32.const 4
    local.get 0
    i32.store

    ;; store the length in the first iovec field
    i32.const 4
    local.get 1
    i32.store offset=4

    ;; call the `fd_write` import
    i32.const 1     ;; stdout fd
    i32.const 4     ;; iovs start
    i32.const 1     ;; number of iovs
    i32.const 0     ;; where to write nwritten bytes
    call $fd_write
    drop
  )

  (memory (export &quot;memory&quot;) 2)
  (global (export &quot;memory_offset&quot;) i32 (i32.const 65536))
)

</code></pre>
<h2><a class="header" href="#linkingc" id="linkingc"><code>linking.c</code></a></h2>
<pre><code class="language-c">/*
Example of compiling, instantiating, and linking two WebAssembly modules
together.

You can compile and run this example on Linux with:

   cargo build --release -p wasmtime-c-api
   cc examples/linking.c \
       -I crates/c-api/include \
       -I crates/c-api/wasm-c-api/include \
       target/release/libwasmtime.a \
       -lpthread -ldl -lm \
       -o linking
   ./linking

Note that on Windows and macOS the command will be similar, but you'll need
to tweak the `-lpthread` and such annotations.
*/

#include &lt;assert.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;wasm.h&gt;
#include &lt;wasi.h&gt;
#include &lt;wasmtime.h&gt;

#define MIN(a, b) ((a) &lt; (b) ? (a) : (b))

static void exit_with_error(const char *message, wasmtime_error_t *error, wasm_trap_t *trap);
static void read_wat_file(wasm_engine_t *engine, wasm_byte_vec_t *bytes, const char *file);

int main() {
  int ret = 0;
  // Set up our context
  wasm_engine_t *engine = wasm_engine_new();
  assert(engine != NULL);
  wasm_store_t *store = wasm_store_new(engine);
  assert(store != NULL);

  wasm_byte_vec_t linking1_wasm, linking2_wasm;
  read_wat_file(engine, &amp;linking1_wasm, &quot;examples/linking1.wat&quot;);
  read_wat_file(engine, &amp;linking2_wasm, &quot;examples/linking2.wat&quot;);

  // Compile our two modules
  wasmtime_error_t *error;
  wasm_module_t *linking1_module = NULL;
  wasm_module_t *linking2_module = NULL;
  error = wasmtime_module_new(engine, &amp;linking1_wasm, &amp;linking1_module);
  if (error != NULL)
    exit_with_error(&quot;failed to compile linking1&quot;, error, NULL);
  error = wasmtime_module_new(engine, &amp;linking2_wasm, &amp;linking2_module);
  if (error != NULL)
    exit_with_error(&quot;failed to compile linking2&quot;, error, NULL);
  wasm_byte_vec_delete(&amp;linking1_wasm);
  wasm_byte_vec_delete(&amp;linking2_wasm);

  // Instantiate wasi
  wasi_config_t *wasi_config = wasi_config_new();
  assert(wasi_config);
  wasi_config_inherit_argv(wasi_config);
  wasi_config_inherit_env(wasi_config);
  wasi_config_inherit_stdin(wasi_config);
  wasi_config_inherit_stdout(wasi_config);
  wasi_config_inherit_stderr(wasi_config);
  wasm_trap_t *trap = NULL;
  wasi_instance_t *wasi = wasi_instance_new(store, &quot;wasi_snapshot_preview1&quot;, wasi_config, &amp;trap);
  if (wasi == NULL)
    exit_with_error(&quot;failed to instantiate wasi&quot;, NULL, trap);

  // Create our linker which will be linking our modules together, and then add
  // our WASI instance to it.
  wasmtime_linker_t *linker = wasmtime_linker_new(store);
  error = wasmtime_linker_define_wasi(linker, wasi);
  if (error != NULL)
    exit_with_error(&quot;failed to link wasi&quot;, error, NULL);

  // Instantiate `linking2` with our linker.
  wasm_instance_t *linking2;
  error = wasmtime_linker_instantiate(linker, linking2_module, &amp;linking2, &amp;trap);
  if (error != NULL || trap != NULL)
    exit_with_error(&quot;failed to instantiate linking2&quot;, error, trap);

  // Register our new `linking2` instance with the linker
  wasm_name_t linking2_name;
  linking2_name.data = &quot;linking2&quot;;
  linking2_name.size = strlen(linking2_name.data);
  error = wasmtime_linker_define_instance(linker, &amp;linking2_name, linking2);
  if (error != NULL)
    exit_with_error(&quot;failed to link linking2&quot;, error, NULL);

  // Instantiate `linking1` with the linker now that `linking2` is defined
  wasm_instance_t *linking1;
  error = wasmtime_linker_instantiate(linker, linking1_module, &amp;linking1, &amp;trap);
  if (error != NULL || trap != NULL)
    exit_with_error(&quot;failed to instantiate linking1&quot;, error, trap);

  // Lookup our `run` export function
  wasm_extern_vec_t linking1_externs;
  wasm_instance_exports(linking1, &amp;linking1_externs);
  assert(linking1_externs.size == 1);
  wasm_func_t *run = wasm_extern_as_func(linking1_externs.data[0]);
  assert(run != NULL);
  error = wasmtime_func_call(run, NULL, 0, NULL, 0, &amp;trap);
  if (error != NULL || trap != NULL)
    exit_with_error(&quot;failed to call run&quot;, error, trap);

  // Clean up after ourselves at this point
  wasm_extern_vec_delete(&amp;linking1_externs);
  wasm_instance_delete(linking1);
  wasm_instance_delete(linking2);
  wasmtime_linker_delete(linker);
  wasm_module_delete(linking1_module);
  wasm_module_delete(linking2_module);
  wasm_store_delete(store);
  wasm_engine_delete(engine);
  return 0;
}

static void read_wat_file(
  wasm_engine_t *engine,
  wasm_byte_vec_t *bytes,
  const char *filename
) {
  wasm_byte_vec_t wat;
  // Load our input file to parse it next
  FILE* file = fopen(filename, &quot;r&quot;);
  if (!file) {
    printf(&quot;&gt; Error loading file!\n&quot;);
    exit(1);
  }
  fseek(file, 0L, SEEK_END);
  size_t file_size = ftell(file);
  wasm_byte_vec_new_uninitialized(&amp;wat, file_size);
  fseek(file, 0L, SEEK_SET);
  if (fread(wat.data, file_size, 1, file) != 1) {
    printf(&quot;&gt; Error loading module!\n&quot;);
    exit(1);
  }
  fclose(file);

  // Parse the wat into the binary wasm format
  wasmtime_error_t *error = wasmtime_wat2wasm(&amp;wat, bytes);
  if (error != NULL)
    exit_with_error(&quot;failed to parse wat&quot;, error, NULL);
  wasm_byte_vec_delete(&amp;wat);
}

static void exit_with_error(const char *message, wasmtime_error_t *error, wasm_trap_t *trap) {
  fprintf(stderr, &quot;error: %s\n&quot;, message);
  wasm_byte_vec_t error_message;
  if (error != NULL) {
    wasmtime_error_message(error, &amp;error_message);
    wasmtime_error_delete(error);
  } else {
    wasm_trap_message(trap, &amp;error_message);
    wasm_trap_delete(trap);
  }
  fprintf(stderr, &quot;%.*s\n&quot;, (int) error_message.size, error_message.data);
  wasm_byte_vec_delete(&amp;error_message);
  exit(1);
}

</code></pre>
<h1><a class="header" href="#debugging-1" id="debugging-1">Debugging</a></h1>
<p>You can also <a href="https://github.com/bytecodealliance/wasmtime/blob/main/examples/fib-debug/main.c">browse this source code online</a> and clone the wasmtime
repository to run the example locally.</p>
<p>This example shows off how to set up a module for dynamic runtime debugging via
a native debugger like GDB or LLDB.</p>
<h2><a class="header" href="#mainc" id="mainc"><code>main.c</code></a></h2>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;inttypes.h&gt;

#include &lt;wasm.h&gt;
#include &quot;wasmtime.h&quot;

#define own

static void exit_with_error(const char *message, wasmtime_error_t *error, wasm_trap_t *trap);

int main(int argc, const char* argv[]) {
  // Configuring engine to support generating of DWARF info.
  // lldb can be used to attach to the program and observe
  // original fib-wasm.c source code and variables.
  wasm_config_t* config = wasm_config_new();
  wasmtime_config_debug_info_set(config, true);

  // Initialize.
  printf(&quot;Initializing...\n&quot;);
  wasm_engine_t* engine = wasm_engine_new_with_config(config);
  wasm_store_t* store = wasm_store_new(engine);

  // Load binary.
  printf(&quot;Loading binary...\n&quot;);
  FILE* file = fopen(&quot;target/wasm32-unknown-unknown/debug/fib.wasm&quot;, &quot;rb&quot;);
  if (!file) {
    printf(&quot;&gt; Error opening module!\n&quot;);
    return 1;
  }
  fseek(file, 0L, SEEK_END);
  size_t file_size = ftell(file);
  fseek(file, 0L, SEEK_SET);
  wasm_byte_vec_t binary;
  wasm_byte_vec_new_uninitialized(&amp;binary, file_size);
  if (fread(binary.data, file_size, 1, file) != 1) {
    printf(&quot;&gt; Error reading module!\n&quot;);
    return 1;
  }
  fclose(file);

  // Compile.
  printf(&quot;Compiling module...\n&quot;);
  wasm_module_t *module = NULL;
  wasmtime_error_t* error = wasmtime_module_new(engine, &amp;binary, &amp;module);
  if (!module)
    exit_with_error(&quot;failed to compile module&quot;, error, NULL);
  wasm_byte_vec_delete(&amp;binary);

  // Figure out which export is the `fib` export
  wasm_exporttype_vec_t module_exports;
  wasm_module_exports(module, &amp;module_exports);
  int fib_idx = -1;
  for (int i = 0; i &lt; module_exports.size; i++) {
    const wasm_name_t *name = wasm_exporttype_name(module_exports.data[i]);
    if (name-&gt;size != 3)
      continue;
    if (strncmp(&quot;fib&quot;, name-&gt;data, 3) != 0)
      continue;
    fib_idx = i;
    break;
  }
  wasm_exporttype_vec_delete(&amp;module_exports);
  if (fib_idx == -1) {
    printf(&quot;&gt; Error finding `fib` export!\n&quot;);
    return 1;
  }

  // Instantiate.
  printf(&quot;Instantiating module...\n&quot;);
  wasm_instance_t* instance = NULL;
  wasm_trap_t *trap = NULL;
  error = wasmtime_instance_new(store, module, NULL, 0, &amp;instance, &amp;trap);
  if (error != NULL || trap != NULL)
    exit_with_error(&quot;failed to instantiate&quot;, error, trap);
  wasm_module_delete(module);

  // Extract export.
  printf(&quot;Extracting export...\n&quot;);
  own wasm_extern_vec_t exports;
  wasm_instance_exports(instance, &amp;exports);
  if (exports.size == 0) {
    printf(&quot;&gt; Error accessing exports!\n&quot;);
    return 1;
  }
  // Getting second export (first is memory).
  wasm_func_t* run_func = wasm_extern_as_func(exports.data[fib_idx]);
  if (run_func == NULL) {
    printf(&quot;&gt; Error accessing export!\n&quot;);
    return 1;
  }

  wasm_instance_delete(instance);

  // Call.
  printf(&quot;Calling fib...\n&quot;);
  wasm_val_t params[1] = { {.kind = WASM_I32, .of = {.i32 = 6}} };
  wasm_val_t results[1];
  error = wasmtime_func_call(run_func, params, 1, results, 1, &amp;trap);
  if (error != NULL || trap != NULL)
    exit_with_error(&quot;failed to call function&quot;, error, trap);

  wasm_extern_vec_delete(&amp;exports);

  printf(&quot;&gt; fib(6) = %d\n&quot;, results[0].of.i32);

  // Shut down.
  printf(&quot;Shutting down...\n&quot;);
  wasm_store_delete(store);
  wasm_engine_delete(engine);

  // All done.
  printf(&quot;Done.\n&quot;);
  return 0;
}

static void exit_with_error(const char *message, wasmtime_error_t *error, wasm_trap_t *trap) {
  fprintf(stderr, &quot;error: %s\n&quot;, message);
  wasm_byte_vec_t error_message;
  if (error != NULL) {
    wasmtime_error_message(error, &amp;error_message);
  } else {
    wasm_trap_message(trap, &amp;error_message);
  }
  fprintf(stderr, &quot;%.*s\n&quot;, (int) error_message.size, error_message.data);
  wasm_byte_vec_delete(&amp;error_message);
  exit(1);
}

</code></pre>
<h1><a class="header" href="#using-multi-value-1" id="using-multi-value-1">Using multi-value</a></h1>
<p>You can also <a href="https://github.com/bytecodealliance/wasmtime/blob/main/examples/multi.c">browse this source code online</a> and clone the wasmtime
repository to run the example locally.</p>
<p>This example shows off how to interact with a wasm module that uses multi-value
exports and imports.</p>
<h2><a class="header" href="#multiwat-1" id="multiwat-1"><code>multi.wat</code></a></h2>
<pre><code class="language-wat">(module
  (func $f (import &quot;&quot; &quot;f&quot;) (param i32 i64) (result i64 i32))

  (func $g (export &quot;g&quot;) (param i32 i64) (result i64 i32)
    (call $f (local.get 0) (local.get 1))
  )

  (func $round_trip_many
    (export &quot;round_trip_many&quot;)
    (param i64 i64 i64 i64 i64 i64 i64 i64 i64 i64)
    (result i64 i64 i64 i64 i64 i64 i64 i64 i64 i64)

    local.get 0
    local.get 1
    local.get 2
    local.get 3
    local.get 4
    local.get 5
    local.get 6
    local.get 7
    local.get 8
    local.get 9)
)

</code></pre>
<h2><a class="header" href="#multic" id="multic"><code>multi.c</code></a></h2>
<pre><code class="language-c">/*
Example of instantiating of the WebAssembly module and invoking its exported
function.

You can compile and run this example on Linux with:

   cargo build --release -p wasmtime-c-api
   cc examples/multi.c \
       -I crates/c-api/include \
       -I crates/c-api/wasm-c-api/include \
       target/release/libwasmtime.a \
       -lpthread -ldl -lm \
       -o multi
   ./multi

Note that on Windows and macOS the command will be similar, but you'll need
to tweak the `-lpthread` and such annotations.

Also note that this example was taken from
https://github.com/WebAssembly/wasm-c-api/blob/master/example/multi.c
originally
*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;inttypes.h&gt;
#include &lt;wasm.h&gt;
#include &lt;wasmtime.h&gt;

static void exit_with_error(const char *message, wasmtime_error_t *error, wasm_trap_t *trap);

// A function to be called from Wasm code.
wasm_trap_t* callback(
  const wasm_val_t args[], wasm_val_t results[]
) {
  printf(&quot;Calling back...\n&quot;);
  printf(&quot;&gt; %&quot;PRIu32&quot; %&quot;PRIu64&quot;\n&quot;, args[0].of.i32, args[1].of.i64);
  printf(&quot;\n&quot;);

  wasm_val_copy(&amp;results[0], &amp;args[1]);
  wasm_val_copy(&amp;results[1], &amp;args[0]);
  return NULL;
}


// A function closure.
wasm_trap_t* closure_callback(
  void* env, const wasm_val_t args[], wasm_val_t results[]
) {
  int i = *(int*)env;
  printf(&quot;Calling back closure...\n&quot;);
  printf(&quot;&gt; %d\n&quot;, i);

  results[0].kind = WASM_I32;
  results[0].of.i32 = (int32_t)i;
  return NULL;
}


int main(int argc, const char* argv[]) {
  // Initialize.
  printf(&quot;Initializing...\n&quot;);
  wasm_engine_t* engine = wasm_engine_new();
  wasm_store_t* store = wasm_store_new(engine);

  // Load our input file to parse it next
  FILE* file = fopen(&quot;examples/multi.wat&quot;, &quot;r&quot;);
  if (!file) {
    printf(&quot;&gt; Error loading file!\n&quot;);
    return 1;
  }
  fseek(file, 0L, SEEK_END);
  size_t file_size = ftell(file);
  fseek(file, 0L, SEEK_SET);
  wasm_byte_vec_t wat;
  wasm_byte_vec_new_uninitialized(&amp;wat, file_size);
  if (fread(wat.data, file_size, 1, file) != 1) {
    printf(&quot;&gt; Error loading module!\n&quot;);
    return 1;
  }
  fclose(file);

  // Parse the wat into the binary wasm format
  wasm_byte_vec_t binary;
  wasmtime_error_t *error = wasmtime_wat2wasm(&amp;wat, &amp;binary);
  if (error != NULL)
    exit_with_error(&quot;failed to parse wat&quot;, error, NULL);
  wasm_byte_vec_delete(&amp;wat);

  // Compile.
  printf(&quot;Compiling module...\n&quot;);
  wasm_module_t* module = NULL;
  error = wasmtime_module_new(engine, &amp;binary, &amp;module);
  if (error)
    exit_with_error(&quot;failed to compile module&quot;, error, NULL);

  wasm_byte_vec_delete(&amp;binary);

  // Create external print functions.
  printf(&quot;Creating callback...\n&quot;);
  wasm_functype_t* callback_type = wasm_functype_new_2_2(
      wasm_valtype_new_i32(),
      wasm_valtype_new_i64(),
      wasm_valtype_new_i64(),
      wasm_valtype_new_i32()
  );
  wasm_func_t* callback_func =
    wasm_func_new(store, callback_type, callback);

  wasm_functype_delete(callback_type);

  // Instantiate.
  printf(&quot;Instantiating module...\n&quot;);
  const wasm_extern_t* imports[] = {wasm_func_as_extern(callback_func)};
  wasm_instance_t* instance = NULL;
  wasm_trap_t* trap = NULL;
  error = wasmtime_instance_new(store, module, imports, 1, &amp;instance, &amp;trap);
  if (!instance)
    exit_with_error(&quot;failed to instantiate&quot;, error, trap);

  wasm_func_delete(callback_func);

  // Extract export.
  printf(&quot;Extracting export...\n&quot;);
  wasm_extern_vec_t exports;
  wasm_instance_exports(instance, &amp;exports);
  if (exports.size == 0) {
    printf(&quot;&gt; Error accessing exports!\n&quot;);
    return 1;
  }
  wasm_func_t* run_func = wasm_extern_as_func(exports.data[0]);
  if (run_func == NULL) {
    printf(&quot;&gt; Error accessing export!\n&quot;);
    return 1;
  }

  wasm_module_delete(module);
  wasm_instance_delete(instance);

  // Call.
  printf(&quot;Calling export...\n&quot;);
  wasm_val_t args[2];
  args[0].kind = WASM_I32;
  args[0].of.i32 = 1;
  args[1].kind = WASM_I64;
  args[1].of.i64 = 2;
  wasm_val_t results[2];
  error = wasmtime_func_call(run_func, args, 2, results, 2, &amp;trap);
  if (error != NULL || trap != NULL)
    exit_with_error(&quot;failed to call run&quot;, error, trap);

  wasm_extern_vec_delete(&amp;exports);

  // Print result.
  printf(&quot;Printing result...\n&quot;);
  printf(&quot;&gt; %&quot;PRIu64&quot; %&quot;PRIu32&quot;\n&quot;,
    results[0].of.i64, results[1].of.i32);

  assert(results[0].kind == WASM_I64);
  assert(results[0].of.i64 == 2);
  assert(results[1].kind == WASM_I32);
  assert(results[1].of.i32 == 1);

  // Shut down.
  printf(&quot;Shutting down...\n&quot;);
  wasm_store_delete(store);
  wasm_engine_delete(engine);

  // All done.
  printf(&quot;Done.\n&quot;);
  return 0;
}

static void exit_with_error(const char *message, wasmtime_error_t *error, wasm_trap_t *trap) {
  fprintf(stderr, &quot;error: %s\n&quot;, message);
  wasm_byte_vec_t error_message;
  if (error != NULL) {
    wasmtime_error_message(error, &amp;error_message);
    wasmtime_error_delete(error);
  } else {
    wasm_trap_message(trap, &amp;error_message);
    wasm_trap_delete(trap);
  }
  fprintf(stderr, &quot;%.*s\n&quot;, (int) error_message.size, error_message.data);
  wasm_byte_vec_delete(&amp;error_message);
  exit(1);
}

</code></pre>
<h1><a class="header" href="#using-webassembly-from-your-language" id="using-webassembly-from-your-language">Using WebAssembly from your Language</a></h1>
<p>Wasmtime can be used as a library to embed WebAssembly execution support
within applications. Wasmtime is written in Rust, but bindings are available
through a C API for a number of other languages too:</p>
<ul>
<li><a href="lang-rust.html">Rust</a></li>
<li><a href="lang-c.html">C</a></li>
<li><a href="lang-python.html">Python</a></li>
<li><a href="lang-dotnet.html">.NET</a></li>
<li><a href="lang-go.html">Go</a></li>
<li><a href="lang-bash.html">Bash</a></li>
</ul>
<h1><a class="header" href="#using-webassembly-from-rust" id="using-webassembly-from-rust">Using WebAssembly from Rust</a></h1>
<p>This document shows an example of how to embed Wasmtime using the <a href="https://bytecodealliance.github.io/wasmtime/api/wasmtime/">Rust
API</a> to execute a simple wasm program. Be sure to also check out the
<a href="https://bytecodealliance.github.io/wasmtime/api/wasmtime/">full API documentation</a> for a full listing of what the <a href="https://crates.io/crates/wasmtime"><code>wasmtime</code>
crate</a> has to offer and the <a href="./examples-rust-embed.html">book examples for
Rust</a> for more information.</p>
<h2><a class="header" href="#creating-the-webassembly-to-execute" id="creating-the-webassembly-to-execute">Creating the WebAssembly to execute</a></h2>
<p>Creation of a WebAssembly file is generally covered by the <a href="./wasm.html">Writing
WebAssembly chapter</a>, so we'll just assume that you've already got a
wasm file on hand for the rest of this tutorial. To make things simple we'll
also just assume you've got a <code>hello.wat</code> file which looks like this:</p>
<pre><code class="language-wat">(module
  (func (export &quot;answer&quot;) (result i32)
     i32.const 42
  )
)
</code></pre>
<p>Here we're just exporting one function which returns an integer that we'll read
from Rust.</p>
<h2><a class="header" href="#hello-world-2" id="hello-world-2">Hello, World!</a></h2>
<p>First up let's create a rust project</p>
<pre><code class="language-sh">$ cargo new --bin wasmtime_hello
$ cd wasmtime_hello
</code></pre>
<p>Next you'll want to add <code>hello.wat</code> to the root of your project.</p>
<p>We will be using the <code>wasmtime</code> crate to run the wasm file, so next up we need a
dependency in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
wasmtime = &quot;0.18.0&quot;
</code></pre>
<p>Next up let's write the code that we need to execute this wasm file. The
simplest version of this looks like so:</p>
<pre><pre class="playpen"><code class="language-rust no_run"># extern crate wasmtime;
use std::error::Error;
use wasmtime::*;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let engine = Engine::default();
    // A `Store` is a sort of &quot;global object&quot; in a sense, but for now it suffices
    // to say that it's generally passed to most constructors.
    let store = Store::new(&amp;engine);

# if false {
    // We start off by creating a `Module` which represents a compiled form
    // of our input wasm module. In this case it'll be JIT-compiled after
    // we parse the text format.
    let module = Module::from_file(&amp;engine, &quot;hello.wat&quot;)?;
# }
# let module = Module::new(&amp;engine, r#&quot;(module (func (export &quot;answer&quot;) (result i32) i32.const 42))&quot;#)?;

    // After we have a compiled `Module` we can then instantiate it, creating
    // an `Instance` which we can actually poke at functions on.
    let instance = Instance::new(&amp;store, &amp;module, &amp;[])?;

    // The `Instance` gives us access to various exported functions and items,
    // which we access here to pull out our `answer` exported function and
    // run it.
    let answer = instance.get_func(&quot;answer&quot;)
        .expect(&quot;`answer` was not an exported function&quot;);

    // There's a few ways we can call the `answer` `Func` value. The easiest
    // is to statically assert its signature with `get0` (in this case asserting
    // it takes no arguments and returns one i32) and then call it.
    let answer = answer.get0::&lt;i32&gt;()?;

    // And finally we can call our function! Note that the error propagation
    // with `?` is done to handle the case where the wasm function traps.
    let result = answer()?;
    println!(&quot;Answer: {:?}&quot;, result);
    Ok(())
}
</code></pre></pre>
<p>We can build and execute our example with <code>cargo run</code>. Note that by depending on
<code>wasmtime</code> you're depending on a JIT compiler, so it may take a moment to build
all of its dependencies:</p>
<pre><code class="language-sh">$ cargo run
  Compiling ...
  ...
   Finished dev [unoptimized + debuginfo] target(s) in 42.32s
    Running `wasmtime_hello/target/debug/wasmtime_hello`
Answer: 42
</code></pre>
<p>and there we go! We've now executed our first WebAssembly in <code>wasmtime</code> and
gotten the result back.</p>
<h2><a class="header" href="#importing-host-functionality" id="importing-host-functionality">Importing Host Functionality</a></h2>
<p>What we've just seen is a pretty small example of how to call a wasm function
and take a look at the result. Most interesting wasm modules, however, are going
to import some functions to do something a bit more interesting. For that you'll
need to provide imported functions from Rust for wasm to call!</p>
<p>Let's take a look at a wasm module which imports a logging function as well as
some simple arithmetic from the environment.</p>
<pre><code class="language-wat">(module
  (import &quot;&quot; &quot;log&quot; (func $log (param i32)))
  (import &quot;&quot; &quot;double&quot; (func $double (param i32) (result i32)))
  (func (export &quot;run&quot;)
    i32.const 0
    call $log
    i32.const 1
    call $log
    i32.const 2
    call $double
    call $log
  )
)
</code></pre>
<p>This wasm module will call our <code>&quot;log&quot;</code> import a few times and then also call the
<code>&quot;double&quot;</code> import. We can compile and instantiate this module with code that
looks like this:</p>
<pre><pre class="playpen"><code class="language-rust no_run"># extern crate wasmtime;
use std::error::Error;
use wasmtime::*;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let engine = Engine::default();
    let store = Store::new(&amp;engine);
# if false {
    let module = Module::from_file(&amp;engine, &quot;hello.wat&quot;)?;
# }
# let module = Module::new(&amp;engine, r#&quot;(module (import &quot;&quot; &quot;log&quot; (func $log (param i32))) (import &quot;&quot; &quot;double&quot; (func $double (param i32) (result i32))) (func (export &quot;run&quot;) i32.const 0 call $log i32.const 1 call $log i32.const 2 call $double call $log))&quot;#)?;

    // First we can create our `log` function, which will simply print out the
    // parameter it receives.
    let log = Func::wrap(&amp;store, |param: i32| {
        println!(&quot;log: {}&quot;, param);
    });

    // Next we can create our double function which doubles the input it receives.
    let double = Func::wrap(&amp;store, |param: i32| param * 2);

    // When instantiating the module we now need to provide the imports to the
    // instantiation process. This is the second slice argument, where each
    // entry in the slice must line up with the imports in the module.
    let instance = Instance::new(&amp;store, &amp;module, &amp;[log.into(), double.into()])?;

    let run = instance
        .get_func(&quot;run&quot;)
        .expect(&quot;`run` was not an exported function&quot;);

    let run = run.get0::&lt;()&gt;()?;

    Ok(run()?)
}
</code></pre></pre>
<p>Note that there's a number of ways to define a <code>Func</code>, be sure to <a href="https://bytecodealliance.github.io/wasmtime/api/wasmtime/struct.Func.html">consult its
documentation</a> for other ways to create a host-defined function.</p>
<h1><a class="header" href="#c" id="c">C</a></h1>
<p>... more coming soon</p>
<p>In the meantime, have a look at the <a href="https://bytecodealliance.github.io/wasmtime/c-api/">C API docs</a>.</p>
<h1><a class="header" href="#using-webassembly-from-python" id="using-webassembly-from-python">Using WebAssembly from Python</a></h1>
<p>Wasmtime <a href="https://pypi.org/project/wasmtime/">is available on PyPI</a> and can be
used programmatically or as a python module loader, which allows almost any
WebAssembly module to be used as a python module. This guide will go over adding
Wasmtime to your project, and some provided examples of what can be done with
WebAssembly modules.</p>
<p>Make sure you've got Python 3.5 or newer installed locally, and we can get
started!</p>
<h2><a class="header" href="#getting-started-and-simple-example" id="getting-started-and-simple-example">Getting started and simple example</a></h2>
<p>First, copy this example WebAssembly text module into your project. It exports a
function for calculating the greatest common denominator of two numbers.</p>
<pre><code class="language-wat">(module
  (func $gcd (param i32 i32) (result i32)
    (local i32)
    block  ;; label = @1
      block  ;; label = @2
        local.get 0
        br_if 0 (;@2;)
        local.get 1
        local.set 2
        br 1 (;@1;)
      end
      loop  ;; label = @2
        local.get 1
        local.get 0
        local.tee 2
        i32.rem_u
        local.set 0
        local.get 2
        local.set 1
        local.get 0
        br_if 0 (;@2;)
      end
    end
    local.get 2
  )
  (export &quot;gcd&quot; (func $gcd))
)


</code></pre>
<p>Next, install the <a href="https://pypi.org/project/wasmtime/">Wasmtime package</a> from
PyPi. It can be installed as a dependency through Pip or related tools such as
Pipenv.</p>
<pre><code class="language-bash">pip install wasmtime
</code></pre>
<p>Or</p>
<pre><code class="language-bash">pipenv install wasmtime
</code></pre>
<p>After you have Wasmtime installed and you've imported <code>wasmtime</code>, you can import
WebAssembly modules in your project like any other python module.</p>
<pre><code class="language-python">import wasmtime.loader
import gcd

print(&quot;gcd(27, 6) =&quot;, gcd.gcd(27, 6))
</code></pre>
<p>This script should output</p>
<pre><code class="language-bash">gcd(27, 6) = 3
</code></pre>
<p>If this is the output you see, congrats! You've successfully ran your first
WebAssembly code in python!</p>
<p>You can also alternatively use the <a href="https://bytecodealliance.github.io/wasmtime-py/"><code>wasmtime</code> package's
API</a>:</p>
<pre><code class="language-python">from wasmtime import Store, Module, Instance

store = Store()
module = Module.from_file(store, 'gcd.wat')
instance = Instance(module, [])
gcd = instance.get_export('gcd')
print(&quot;gcd(27, 6) =&quot;, gcd(27, 6))
</code></pre>
<h2><a class="header" href="#more-examples-and-contributing" id="more-examples-and-contributing">More examples and contributing</a></h2>
<p>The <code>wasmtime</code> Python package currently <a href="https://github.com/bytecodealliance/wasmtime-py">lives in its own repository outside of
<code>wasmtime</code></a> and has a <a href="https://github.com/bytecodealliance/wasmtime-py/tree/main/examples">number
of other more advanced
examples</a>
as well. Feel free to browse those, but if you find anything missing don't
hesitate to <a href="https://github.com/bytecodealliance/wasmtime-py/issues/new">open an
issue</a> and let us
know if you have any questions!</p>
<h1><a class="header" href="#using-webassembly-from-net" id="using-webassembly-from-net">Using WebAssembly from .NET</a></h1>
<p>The <a href="https://www.nuget.org/packages/Wasmtime">Wasmtime</a> NuGet package can be used to
programmatically interact with WebAssembly modules.</p>
<p>This guide will go over adding Wasmtime to your project and demonstrate a simple
example of using a WebAssembly module from C#.</p>
<p>Make sure you have a <a href="https://dotnet.microsoft.com/download">.NET Core SDK 3.0 SDK or later</a>
installed before we get started!</p>
<h2><a class="header" href="#getting-started-and-simple-example-1" id="getting-started-and-simple-example-1">Getting started and simple example</a></h2>
<p>Start by creating a new .NET Core console project:</p>
<pre><code class="language-text">$ mkdir gcd
$ cd gcd
$ dotnet new console
</code></pre>
<p>Next, add a reference to the Wasmtime NuGet package to your project:</p>
<pre><code class="language-text">$ dotnet add package --version 0.19.0-preview1 wasmtime
</code></pre>
<p>Copy this example WebAssembly text module into your project directory as <code>gcd.wat</code>.</p>
<pre><code class="language-wat">(module
  (func $gcd (param i32 i32) (result i32)
    (local i32)
    block  ;; label = @1
      block  ;; label = @2
        local.get 0
        br_if 0 (;@2;)
        local.get 1
        local.set 2
        br 1 (;@1;)
      end
      loop  ;; label = @2
        local.get 1
        local.get 0
        local.tee 2
        i32.rem_u
        local.set 0
        local.get 2
        local.set 1
        local.get 0
        br_if 0 (;@2;)
      end
    end
    local.get 2
  )
  (export &quot;gcd&quot; (func $gcd))
)


</code></pre>
<p>This module exports a function for calculating the greatest common denominator of two numbers.</p>
<p>Replace the code in <code>Program.cs</code> with the following:</p>
<pre><code class="language-c#">using System;
using Wasmtime;

namespace Tutorial
{
    class Program
    {
        static void Main(string[] args)
        {
            using var engine = new Engine();
            using var module = Module.FromTextFile(engine, &quot;gcd.wat&quot;);

            using var host = new Host(engine);
            using dynamic instance = host.Instantiate(module);

            Console.WriteLine($&quot;gcd(27, 6) = {instance.gcd(27, 6)}&quot;);
        }
    }
}
</code></pre>
<p>Run the .NET core program:</p>
<pre><code class="language-text">$ dotnet run
</code></pre>
<p>The program should output:</p>
<pre><code class="language-text">gcd(27, 6) = 3
</code></pre>
<p>If this is the output you see, congrats! You've successfully ran your first
WebAssembly code in .NET!</p>
<h2><a class="header" href="#more-examples-and-contributing-1" id="more-examples-and-contributing-1">More examples and contributing</a></h2>
<p>The <a href="https://github.com/bytecodealliance/wasmtime-dotnet">.NET embedding of Wasmtime repository</a>
contains the source code for the Wasmtime NuGet package.</p>
<p>The repository also has more <a href="https://github.com/bytecodealliance/wasmtime-dotnet/tree/main/examples">examples</a>
as well.</p>
<p>Feel free to browse those, but if you find anything missing don't
hesitate to <a href="https://github.com/bytecodealliance/wasmtime-dotnet/issues/new">open an issue</a> and let us
know if you have any questions!</p>
<h1><a class="header" href="#go" id="go">Go</a></h1>
<p>Wasmtime <a href="https://pkg.go.dev/github.com/bytecodealliance/wasmtime-go">is available as a Go
Module</a>. This guide
will go over adding Wasmtime to your project, and some provided examples of what
can be done with WebAssembly modules.</p>
<p>Make sure you're using Go 1.12 or later with modules support.</p>
<h2><a class="header" href="#getting-started-and-simple-example-2" id="getting-started-and-simple-example-2">Getting started and simple example</a></h2>
<p>First up you'll want to start a new module:</p>
<pre><code class="language-sh">$ mkdir hello-wasm
$ cd hello-wasm
$ go mod init hello-wasm
</code></pre>
<p>Next, copy this example WebAssembly text module into your project. It exports a
function for calculating the greatest common denominator of two numbers.</p>
<pre><code class="language-wat">(module
  (func $gcd (param i32 i32) (result i32)
    (local i32)
    block  ;; label = @1
      block  ;; label = @2
        local.get 0
        br_if 0 (;@2;)
        local.get 1
        local.set 2
        br 1 (;@1;)
      end
      loop  ;; label = @2
        local.get 1
        local.get 0
        local.tee 2
        i32.rem_u
        local.set 0
        local.get 2
        local.set 1
        local.get 0
        br_if 0 (;@2;)
      end
    end
    local.get 2
  )
  (export &quot;gcd&quot; (func $gcd))
)


</code></pre>
<p>Next, we can write our code in <code>main.go</code> which reads this file and runs it:</p>
<pre><code class="language-go">package main

import (
    &quot;fmt&quot;
    &quot;github.com/bytecodealliance/wasmtime-go&quot;
)

func main() {
    engine := wasmtime.NewEngine()
    store := wasmtime.NewStore(engine)
    module, err := wasmtime.NewModuleFromFile(engine, &quot;gcd.wat&quot;)
    check(err)
    instance, err := wasmtime.NewInstance(store, module, []*wasmtime.Extern{})
    check(err)

    gcd := instance.GetExport(&quot;gcd&quot;).Func()
    val, err := gcd.Call(6, 27)
    check(err)
    fmt.Printf(&quot;gcd(6, 27) = %d\n&quot;, val.(int32))
}

func check(err error) {
    if err != nil {
        panic(err)
    }
}
</code></pre>
<p>And finally we can build and run it:</p>
<pre><code class="language-sh">$ go run main.go
gcd(6, 27) = 3
</code></pre>
<p>If this is the output you see, congrats! You've successfully ran your first
WebAssembly code in Go!</p>
<h2><a class="header" href="#more-examples-and-contributing-2" id="more-examples-and-contributing-2">More examples and contributing</a></h2>
<p>The <code>wasmtime</code> Go package <a href="https://github.com/bytecodealliance/wasmtime-go">lives in its own
repository</a> and has a <a href="https://pkg.go.dev/github.com/bytecodealliance/wasmtime-go?tab=doc#pkg-examples">number
of other more advanced
examples</a>
as well. Feel free to browse those, but if you find anything missing don't
hesitate to <a href="https://github.com/bytecodealliance/wasmtime-go/issues/new">open an
issue</a> and let us
know if you have any questions!</p>
<h1><a class="header" href="#using-webassembly-from-bash" id="using-webassembly-from-bash">Using WebAssembly from Bash</a></h1>
<p>... more coming soon</p>
<h1><a class="header" href="#using-the-wasmtime-cli" id="using-the-wasmtime-cli">Using the <code>wasmtime</code> CLI</a></h1>
<p>In addition to the embedding API which allows you to use Wasmtime as a
library, the Wasmtime project also provides a <code>wasmtime</code> CLI tool to conveniently
execute WebAssembly modules from the command line.</p>
<p>This section will provide a guide to the <code>wasmtime</code> CLI and major functionality
that it contains. In short, however, you can execute a WebAssembly file
(actually doing work as part of the <code>start</code> function) like so:</p>
<pre><code class="language-sh">$ wasmtime foo.wasm
</code></pre>
<p>Or similarly if you want to invoke a &quot;start&quot; function, such as with WASI
modules, you can execute</p>
<pre><code class="language-sh">$ wasmtime --invoke _start foo.wasm
</code></pre>
<p>For more information be sure to check out <a href="cli-install.html">how to install the
CLI</a>, <a href="cli-options.html">the list of options you can
pass</a>, and <a href="cli-logging.html">how to enable logging</a>.</p>
<h1><a class="header" href="#installing-wasmtime-1" id="installing-wasmtime-1">Installing <code>wasmtime</code></a></h1>
<p>Here we'll show you how to install the <code>wasmtime</code> command line tool. Note that
this is distinct from embedding the Wasmtime project into another, for that
you'll want to consult the <a href="embed.html">embedding documentation</a>.</p>
<p>The easiest way to install the <code>wasmtime</code> CLI tool is through our installation
script. Linux and macOS users can execute the following:</p>
<pre><code class="language-sh">$ curl https://wasmtime.dev/install.sh -sSf | bash
</code></pre>
<p>This will download a precompiled version of <code>wasmtime</code> and place it in
<code>$HOME/.wasmtime</code>, and update your shell configuration to place the right
directory in <code>PATH</code>.</p>
<p>Windows users will want to visit our <a href="https://github.com/bytecodealliance/wasmtime/releases">releases page</a> and can download
the MSI installer (<code>wasmtime-dev-x86_64-windows.msi</code> for example) and use that
to install.</p>
<p>You can confirm your installation works by executing:</p>
<pre><code class="language-sh">$ wasmtime -V
wasmtime 0.12.0
</code></pre>
<p>And now you're off to the races! Be sure to check out the <a href="cli-options.html">various CLI
options</a> as well.</p>
<h2><a class="header" href="#download-precompiled-binaries" id="download-precompiled-binaries">Download Precompiled Binaries</a></h2>
<p>If you'd prefer to not use an installation script, or you're perhaps
orchestrating something in CI, you can also download one of our precompiled
binaries of <code>wasmtime</code>. We have two channels of releases right now for
precompiled binaries:</p>
<ol>
<li>Each tagged release will have a full set of release artifacts on the <a href="https://github.com/bytecodealliance/wasmtime/releases">GitHub
releases page</a>.</li>
<li>The <a href="https://github.com/bytecodealliance/wasmtime/releases/tag/dev"><code>dev</code> release</a> is also continuously updated with the latest build of the
<code>main</code> branch. If you want the latest-and-greatest and don't mind a bit of
instability, this is the release for you.</li>
</ol>
<p>When downloading binaries you'll likely want one of the following archives (for
the <code>dev</code> release)</p>
<ul>
<li>Linux users - [<code>wasmtime-dev-x86_64-linux.tar.xz</code>]</li>
<li>macOS users - [<code>wasmtime-dev-x86_64-macos.tar.xz</code>]</li>
<li>Windows users - [<code>wasmtime-dev-x86_64-windows.zip</code>]</li>
</ul>
<p>Each of these archives has a <code>wasmtime</code> binary placed inside which can be
executed normally as the CLI would.</p>
<h2><a class="header" href="#compiling-from-source" id="compiling-from-source">Compiling from Source</a></h2>
<p>If you'd prefer to compile the <code>wasmtime</code> CLI from source, you'll want to
consult the <a href="contributing-building.html">contributing documentation for building</a>.
Be sure to use a <code>--release</code> build if you're curious to do benchmarking!</p>
<h1><a class="header" href="#cli-options-for-wasmtime" id="cli-options-for-wasmtime">CLI Options for <code>wasmtime</code></a></h1>
<p>The <code>wasmtime</code> CLI is organized into a few subcommands. If no subcommand is
provided it'll assume <code>run</code>, which is to execute a wasm file. The subcommands
supported by <code>wasmtime</code> are:</p>
<h2><a class="header" href="#help" id="help"><code>help</code></a></h2>
<p>This is a general subcommand used to print help information to the terminal. You
can execute any number of the following:</p>
<pre><code class="language-sh">$ wasmtime help
$ wasmtime --help
$ wasmtime -h
$ wasmtime help run
$ wasmtime run -h
</code></pre>
<p>When in doubt, try running the <code>help</code> command to learn more about functionality!</p>
<h2><a class="header" href="#run" id="run"><code>run</code></a></h2>
<p>This is the <code>wasmtime</code> CLI's main subcommand, and it's also the default if no
other subcommand is provided. The <code>run</code> command will execute a WebAssembly
module. This means that the module will be compiled to native code,
instantiated, and then optionally have an export executed.</p>
<p>The <code>wasmtime</code> CLI will automatically hook up any WASI-related imported
functionality, but at this time if your module imports anything else it will
fail instantiation.</p>
<p>The <code>run</code> command takes one positional argument which is the name of the module
to run:</p>
<pre><code class="language-sh">$ wasmtime run foo.wasm
$ wasmtime foo.wasm
</code></pre>
<p>Note that the <code>wasmtime</code> CLI can take both a binary WebAssembly file (<code>*.wasm</code>)
as well as the text format for WebAssembly (<code>*.wat</code>):</p>
<pre><code class="language-sh">$ wasmtime foo.wat
</code></pre>
<h2><a class="header" href="#wast" id="wast"><code>wast</code></a></h2>
<p>The <code>wast</code> command executes a <code>*.wast</code> file which is the test format for the
official WebAssembly spec test suite. This subcommand will execute the script
file which has a number of directives supported to instantiate modules, link
tests, etc.</p>
<p>Executing this looks like:</p>
<pre><code class="language-sh">$ wasmtime wast foo.wast
</code></pre>
<h2><a class="header" href="#config" id="config"><code>config</code></a></h2>
<p>This subcommand is used to control and edit local Wasmtime configuration
settings. The primary purpose of this currently is to configure <a href="./cli-cache.html">how Wasmtime's
code caching works</a>. You can create a new configuration file for
you to edit with:</p>
<pre><code class="language-sh">$ wasmtime config new
</code></pre>
<p>And that'll print out the path to the file you can edit.</p>
<h2><a class="header" href="#wasm2obj" id="wasm2obj"><code>wasm2obj</code></a></h2>
<p>This is an experimental subcommand to compile a WebAssembly module to native
code. Work for this is still heavily under development, but you can execute this
with:</p>
<pre><code class="language-sh">$ wasmtime wasm2obj foo.wasm foo.o
</code></pre>
<h1><a class="header" href="#cache-configuration-of-wasmtime" id="cache-configuration-of-wasmtime">Cache Configuration of <code>wasmtime</code></a></h1>
<p>The configuration file uses the <a href="https://github.com/toml-lang/toml">toml</a> format.
You can create a configuration file at the default location with:</p>
<pre><code class="language-sh">$ wasmtime config new
</code></pre>
<p>It will print the location regardless of the success.
Please refer to the  <code>--help</code> message for using a custom location.</p>
<p>All settings, except <code>enabled</code>, are <strong>optional</strong>.
If the setting is not specified, the <strong>default</strong> value is used.
<em><strong>Thus, if you don't know what values to use, don't specify them.</strong></em>
The default values might be tuned in the future.</p>
<p>Wasmtime assumes all the options are in the <code>cache</code> section.</p>
<p>Example config:</p>
<pre><code class="language-toml">[cache]
enabled = true
directory = &quot;/nfs-share/wasmtime-cache/&quot;
cleanup-interval = &quot;30m&quot;
files-total-size-soft-limit = &quot;1Gi&quot;
</code></pre>
<p>Please refer to the <a href="cli-cache.html#how-does-the-cache-work">cache system</a> section to learn how it works.</p>
<p>If you think some default value should be tuned, some new settings
should be introduced or some behavior should be changed, you are
welcome to discuss it and contribute to <a href="https://github.com/bytecodealliance/wasmtime">the Wasmtime repository</a>.</p>
<h2><a class="header" href="#setting-enabled" id="setting-enabled">Setting <code>enabled</code></a></h2>
<ul>
<li><strong>type</strong>: boolean</li>
<li><strong>format</strong>: <code>true | false</code></li>
<li><strong>default</strong>: <code>true</code></li>
</ul>
<p>Specifies whether the cache system is used or not.</p>
<p>This field is <em>mandatory</em>.
The default value is used when configuration file is not specified
and none exists at the default location.</p>
<h2><a class="header" href="#setting-directory" id="setting-directory">Setting <code>directory</code></a></h2>
<ul>
<li><strong>type</strong>: string (path)</li>
<li><strong>default</strong>: look up <code>cache_dir</code> in <a href="https://crates.io/crates/directories">directories</a> crate</li>
</ul>
<p>Specifies where the cache directory is. Must be an absolute path.</p>
<h2><a class="header" href="#setting-worker-event-queue-size" id="setting-worker-event-queue-size">Setting <code>worker-event-queue-size</code></a></h2>
<ul>
<li><strong>type</strong>: string (SI prefix)</li>
<li><strong>format</strong>: <code>&quot;{integer}(K | M | G | T | P)?&quot;</code></li>
<li><strong>default</strong>: <code>&quot;16&quot;</code></li>
</ul>
<p>Size of <a href="cli-cache.html#how-does-the-cache-work">cache worker</a> event queue.
If the queue is full, incoming cache usage events will be dropped.</p>
<h2><a class="header" href="#setting-baseline-compression-level" id="setting-baseline-compression-level">Setting <code>baseline-compression-level</code></a></h2>
<ul>
<li><strong>type</strong>: integer</li>
<li><strong>default</strong>: <code>3</code>, the default zstd compression level</li>
</ul>
<p>Compression level used when a new cache file is being written by the <a href="cli-cache.html#how-does-the-cache-work">cache system</a>.
Wasmtime uses <a href="https://facebook.github.io/zstd/">zstd</a> compression.</p>
<h2><a class="header" href="#setting-optimized-compression-level" id="setting-optimized-compression-level">Setting <code>optimized-compression-level</code></a></h2>
<ul>
<li><strong>type</strong>: integer</li>
<li><strong>default</strong>: <code>20</code></li>
</ul>
<p>Compression level used when the <a href="cli-cache.html#how-does-the-cache-work">cache worker</a> decides to recompress a cache file.
Wasmtime uses <a href="https://facebook.github.io/zstd/">zstd</a> compression.</p>
<h2><a class="header" href="#setting-optimized-compression-usage-counter-threshold" id="setting-optimized-compression-usage-counter-threshold">Setting <code>optimized-compression-usage-counter-threshold</code></a></h2>
<ul>
<li><strong>type</strong>: string (SI prefix)</li>
<li><strong>format</strong>: <code>&quot;{integer}(K | M | G | T | P)?&quot;</code></li>
<li><strong>default</strong>: <code>&quot;256&quot;</code></li>
</ul>
<p>One of the conditions for the <a href="cli-cache.html#how-does-the-cache-work">cache worker</a> to recompress a cache file
is to have usage count of the file exceeding this threshold.</p>
<h2><a class="header" href="#setting-cleanup-interval" id="setting-cleanup-interval">Setting <code>cleanup-interval</code></a></h2>
<ul>
<li><strong>type</strong>: string (duration)</li>
<li><strong>format</strong>: <code>&quot;{integer}(s | m | h | d)&quot;</code></li>
<li><strong>default</strong>: <code>&quot;1h&quot;</code></li>
</ul>
<p>When the <a href="cli-cache.html#how-does-the-cache-work">cache worker</a> is notified about a cache file being updated by the <a href="cli-cache.html#how-does-the-cache-work">cache system</a>
and this interval has already passed since last cleaning up,
the worker will attempt a new cleanup.</p>
<p>Please also refer to <a href="cli-cache.html#setting-allowed-clock-drift-for-files-from-future"><code>allowed-clock-drift-for-files-from-future</code></a>.</p>
<h2><a class="header" href="#setting-optimizing-compression-task-timeout" id="setting-optimizing-compression-task-timeout">Setting <code>optimizing-compression-task-timeout</code></a></h2>
<ul>
<li><strong>type</strong>: string (duration)</li>
<li><strong>format</strong>: <code>&quot;{integer}(s | m | h | d)&quot;</code></li>
<li><strong>default</strong>: <code>&quot;30m&quot;</code></li>
</ul>
<p>When the <a href="cli-cache.html#how-does-the-cache-work">cache worker</a> decides to recompress a cache file, it makes sure that
no other worker has started the task for this file within the last
<a href="cli-cache.html#setting-optimizing-compression-task-timeout"><code>optimizing-compression-task-timeout</code></a> interval.
If some worker has started working on it, other workers are skipping this task.</p>
<p>Please also refer to the <a href="cli-cache.html#setting-allowed-clock-drift-for-files-from-future"><code>allowed-clock-drift-for-files-from-future</code></a> section.</p>
<h2><a class="header" href="#setting-allowed-clock-drift-for-files-from-future" id="setting-allowed-clock-drift-for-files-from-future">Setting <code>allowed-clock-drift-for-files-from-future</code></a></h2>
<ul>
<li><strong>type</strong>: string (duration)</li>
<li><strong>format</strong>: <code>&quot;{integer}(s | m | h | d)&quot;</code></li>
<li><strong>default</strong>: <code>&quot;1d&quot;</code></li>
</ul>
<h3><a class="header" href="#locks" id="locks">Locks</a></h3>
<p>When the <a href="cli-cache.html#how-does-the-cache-work">cache worker</a> attempts acquiring a lock for some task,
it checks if some other worker has already acquired such a lock.
To be fault tolerant and eventually execute every task,
the locks expire after some interval.
However, because of clock drifts and different timezones,
it would happen that some lock was created in the future.
This setting defines a tolerance limit for these locks.
If the time has been changed in the system (i.e. two years backwards),
the <a href="cli-cache.html#how-does-the-cache-work">cache system</a> should still work properly.
Thus, these locks will be treated as expired
(assuming the tolerance is not too big).</p>
<h3><a class="header" href="#cache-files" id="cache-files">Cache files</a></h3>
<p>Similarly to the locks, the cache files or their metadata might
have modification time in distant future.
The cache system tries to keep these files as long as possible.
If the limits are not reached, the cache files will not be deleted.
Otherwise, they will be treated as the oldest files, so they might survive.
If the user actually uses the cache file, the modification time will be updated.</p>
<h2><a class="header" href="#setting-file-count-soft-limit" id="setting-file-count-soft-limit">Setting <code>file-count-soft-limit</code></a></h2>
<ul>
<li><strong>type</strong>: string (SI prefix)</li>
<li><strong>format</strong>: <code>&quot;{integer}(K | M | G | T | P)?&quot;</code></li>
<li><strong>default</strong>: <code>&quot;65536&quot;</code></li>
</ul>
<p>Soft limit for the file count in the cache directory.</p>
<p>This doesn't include files with metadata.
To learn more, please refer to the <a href="cli-cache.html#how-does-the-cache-work">cache system</a> section.</p>
<h2><a class="header" href="#setting-files-total-size-soft-limit" id="setting-files-total-size-soft-limit">Setting <code>files-total-size-soft-limit</code></a></h2>
<ul>
<li><strong>type</strong>: string (disk space)</li>
<li><strong>format</strong>: <code>&quot;{integer}(K | Ki | M | Mi | G | Gi | T | Ti | P | Pi)?&quot;</code></li>
<li><strong>default</strong>: <code>&quot;512Mi&quot;</code></li>
</ul>
<p>Soft limit for the total size* of files in the cache directory.</p>
<p>This doesn't include files with metadata.
To learn more, please refer to the <a href="cli-cache.html#how-does-the-cache-work">cache system</a> section.</p>
<p>*this is the file size, not the space physically occupied on the disk.</p>
<h2><a class="header" href="#setting-file-count-limit-percent-if-deleting" id="setting-file-count-limit-percent-if-deleting">Setting <code>file-count-limit-percent-if-deleting</code></a></h2>
<ul>
<li><strong>type</strong>: string (percent)</li>
<li><strong>format</strong>: <code>&quot;{integer}%&quot;</code></li>
<li><strong>default</strong>: <code>&quot;70%&quot;</code></li>
</ul>
<p>If <a href="cli-cache.html#setting-file-count-soft-limit"><code>file-count-soft-limit</code></a> is exceeded and the <a href="cli-cache.html#how-does-the-cache-work">cache worker</a> performs the cleanup task,
then the worker will delete some cache files, so after the task,
the file count should not exceed
<a href="cli-cache.html#setting-file-count-soft-limit"><code>file-count-soft-limit</code></a> * <a href="cli-cache.html#setting-file-count-limit-percent-if-deleting"><code>file-count-limit-percent-if-deleting</code></a>.</p>
<p>This doesn't include files with metadata.
To learn more, please refer to the <a href="cli-cache.html#how-does-the-cache-work">cache system</a> section.</p>
<h2><a class="header" href="#setting-files-total-size-limit-percent-if-deleting" id="setting-files-total-size-limit-percent-if-deleting">Setting <code>files-total-size-limit-percent-if-deleting</code></a></h2>
<ul>
<li><strong>type</strong>: string (percent)</li>
<li><strong>format</strong>: <code>&quot;{integer}%&quot;</code></li>
<li><strong>default</strong>: <code>&quot;70%&quot;</code></li>
</ul>
<p>If <a href="cli-cache.html#setting-files-total-size-soft-limit"><code>files-total-size-soft-limit</code></a> is exceeded and <a href="cli-cache.html#how-does-the-cache-work">cache worker</a> performs the cleanup task,
then the worker will delete some cache files, so after the task,
the files total size should not exceed
<a href="cli-cache.html#setting-files-total-size-soft-limit"><code>files-total-size-soft-limit</code></a> * <a href="cli-cache.html#setting-files-total-size-limit-percent-if-deleting"><code>files-total-size-limit-percent-if-deleting</code></a>.</p>
<p>This doesn't include files with metadata.
To learn more, please refer to the <a href="cli-cache.html#how-does-the-cache-work">cache system</a> section.</p>
<h1><a class="header" href="#how-does-the-cache-work" id="how-does-the-cache-work">How does the cache work?</a></h1>
<p><strong>This is an implementation detail and might change in the future.</strong>
Information provided here is meant to help understanding the big picture
and configuring the cache.</p>
<p>There are two main components - the <em>cache system</em> and the <em>cache worker</em>.</p>
<h2><a class="header" href="#cache-system" id="cache-system">Cache system</a></h2>
<p>Handles GET and UPDATE cache requests.</p>
<ul>
<li><strong>GET request</strong> - simply loads the cache from disk if it is there.</li>
<li><strong>UPDATE request</strong> - compresses received data with <a href="https://facebook.github.io/zstd/">zstd</a> and <a href="cli-cache.html#setting-baseline-compression-level"><code>baseline-compression-level</code></a>, then writes the data to the disk.</li>
</ul>
<p>In case of successful handling of a request, it notifies the <em>cache worker</em> about this
event using the queue.
The queue has a limited size of <a href="cli-cache.html#setting-worker-event-queue-size"><code>worker-event-queue-size</code></a>. If it is full, it will drop
new events until the <em>cache worker</em> pops some event from the queue.</p>
<h2><a class="header" href="#cache-worker" id="cache-worker">Cache worker</a></h2>
<p>The cache worker runs in a single thread with lower priority and pops events from the queue
in a loop handling them one by one.</p>
<h3><a class="header" href="#on-get-request" id="on-get-request">On GET request</a></h3>
<ol>
<li>
<p>Read the statistics file for the cache file,
increase the usage counter and write it back to the disk.</p>
</li>
<li>
<p>Attempt recompressing the cache file if all of the following conditions are met:</p>
<ul>
<li>usage counter exceeds <a href="cli-cache.html#setting-optimized-compression-usage-counter-threshold"><code>optimized-compression-usage-counter-threshold</code></a>,</li>
<li>the file is compressed with compression level lower than <a href="cli-cache.html#setting-optimized-compression-level"><code>optimized-compression-level</code></a>,</li>
<li>no other worker has started working on this particular task within the last
<a href="cli-cache.html#setting-optimizing-compression-task-timeout"><code>optimizing-compression-task-timeout</code></a> interval.</li>
</ul>
<p>When recompressing, <a href="cli-cache.html#setting-optimized-compression-level"><code>optimized-compression-level</code></a> is used as a compression level.</p>
</li>
</ol>
<h3><a class="header" href="#on-update-request" id="on-update-request">On UPDATE request</a></h3>
<ol>
<li>Write a fresh statistics file for the cache file.</li>
<li>Clean up the cache if no worker has attempted to do this within the last <a href="cli-cache.html#setting-cleanup-interval"><code>cleanup-interval</code></a>.
During this task:
<ul>
<li>all unrecognized files and expired task locks in cache directory will be deleted</li>
<li>if <a href="cli-cache.html#setting-file-count-soft-limit"><code>file-count-soft-limit</code></a> or <a href="cli-cache.html#setting-files-total-size-soft-limit"><code>files-total-size-soft-limit</code></a> is exceeded,
then recognized files will be deleted according to
<a href="cli-cache.html#setting-file-count-limit-percent-if-deleting"><code>file-count-limit-percent-if-deleting</code></a> and <a href="cli-cache.html#setting-files-total-size-limit-percent-if-deleting"><code>files-total-size-limit-percent-if-deleting</code></a>.
Wasmtime uses <a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#Least_recently_used_(LRU)">Least Recently Used (LRU)</a> cache replacement policy and requires that
the filesystem maintains proper mtime (modification time) of the files.
Files with future mtimes are treated specially - more details
in <a href="cli-cache.html#setting-allowed-clock-drift-for-files-from-future"><code>allowed-clock-drift-for-files-from-future</code></a>.</li>
</ul>
</li>
</ol>
<h3><a class="header" href="#metadata-files" id="metadata-files">Metadata files</a></h3>
<ul>
<li>every cached WebAssembly module has its own statistics file</li>
<li>every lock is a file</li>
</ul>
<h1><a class="header" href="#writing-webassembly" id="writing-webassembly">Writing WebAssembly</a></h1>
<p>Wasmtime is a runtime for <em>executing</em> WebAssembly but you also at some point
need to actually produce the WebAssembly module to feed into Wasmtime! This
section of the guide is intended to provide some introductory documentation for
compiling source code to WebAssembly to later run in Wasmtime. There's plenty of
other documentation on the web for doing this, so you'll want to be sure to
check out your language's documentation for WebAssembly as well.</p>
<ul>
<li><a href="wasm-rust.html">Rust</a></li>
<li><a href="wasm-c.html">C/C++</a></li>
<li><a href="wasm-assemblyscript.html">AssemblyScript</a></li>
<li><a href="wasm-wat.html">WebAssembly Text Format (<code>*.wat</code>)</a></li>
</ul>
<h1><a class="header" href="#rust" id="rust">Rust</a></h1>
<p>The <a href="https://www.rust-lang.org">Rust Programming Language</a> supports WebAssembly
as a compilation target. If you're not familiar with Rust it's recommended to
start <a href="https://www.rust-lang.org/learn">with its introductory documentation</a>.
Compiling to WebAssembly will involve specifying the desired target via the
<code>--target</code> flag, and to do this there are a number of &quot;target triples&quot; for
WebAssembly compilation in Rust:</p>
<ul>
<li><code>wasm32-wasi</code> - when using <code>wasmtime</code> this is likely what you'll be using. The
WASI target is integrated into the standard library and is intended on
producing standalone binaries.</li>
<li><code>wasm32-unknown-unknown</code> - this target, like the WASI one, is focused on
producing single <code>*.wasm</code> binaries. The standard library, however, is largely
stubbed out since the &quot;unknown&quot; part of the target means libstd can't assume
anything. This means that while binaries will likely work in <code>wasmtime</code>,
common conveniences like <code>println!</code> or <code>panic!</code> won't work.</li>
<li><code>wasm32-unknown-emscripten</code> - this target is intended to work in a web browser
and produces a <code>*.wasm</code> file coupled with a <code>*.js</code> file, and it is not
compatible with <code>wasmtime</code>.</li>
</ul>
<p>For the rest of this documentation we'll assume that you're using the
<code>wasm32-wasi</code> target for compiling Rust code and executing inside of <code>wasmtime</code>.</p>
<h2><a class="header" href="#hello-world-3" id="hello-world-3">Hello, World!</a></h2>
<p>Cross-compiling to WebAssembly involves a number of knobs that need
configuration, but you can often gloss over these internal details by using
build tooling intended for the WASI target. For example we can start out writing
a WebAssembly binary with <a href="https://github.com/bytecodealliance/cargo-wasi"><code>cargo wasi</code></a>.</p>
<p>First up we'll <a href="https://bytecodealliance.github.io/cargo-wasi/install.html">install <code>cargo wasi</code></a>:</p>
<pre><code class="language-sh">$ cargo install cargo-wasi
</code></pre>
<p>Next we'll make a new Cargo project:</p>
<pre><code class="language-sh">$ cargo new hello-world
$ cd hello-world
</code></pre>
<p>Inside of <code>src/main.rs</code> you'll see the canonical Rust &quot;Hello, World!&quot; using
<code>println!</code>. We'll be executing this for the <code>wasm32-wasi</code> target, so you'll want
to make sure you're previously <a href="./cli-install.html">built <code>wasmtime</code> and inserted it into
<code>PATH</code></a>;</p>
<pre><code class="language-sh">$ cargo wasi run
info: downloading component 'rust-std' for 'wasm32-wasi'
info: installing component 'rust-std' for 'wasm32-wasi'
   Compiling hello-world v0.1.0 (/hello-world)
    Finished dev [unoptimized + debuginfo] target(s) in 0.16s
     Running `/.cargo/bin/cargo-wasi target/wasm32-wasi/debug/hello-world.wasm`
     Running `target/wasm32-wasi/debug/hello-world.wasm`
Hello, world!
</code></pre>
<p>And we're already running our first WebAssembly code inside of <code>wasmtime</code>!</p>
<p>While it's automatically happening for you as part of <code>cargo wasi</code>, you can also
run <code>wasmtime</code> yourself:</p>
<pre><code class="language-sh">$ wasmtime target/wasm32-wasi/debug/hello-world.wasm
Hello, world!
</code></pre>
<p>You can check out the <a href="https://bytecodealliance.github.io/cargo-wasi/hello-world.html">introductory documentation of
<code>cargo-wasi</code></a> as
well for some more information.</p>
<h2><a class="header" href="#writing-libraries" id="writing-libraries">Writing Libraries</a></h2>
<p>Previously for &quot;Hello, World!&quot; we created a <em>binary</em> project which used
<code>src/main.rs</code>. Not all <code>*.wasm</code> binaries are intended to be executed like
commands, though. Some are intended to be loaded into applications and called
through various APIs, acting more like libraries. For this use case you'll want
to add this to <code>Cargo.toml</code>:</p>
<pre><code class="language-toml"># in Cargo.toml ...

[lib]
crate-type = ['cdylib']
</code></pre>
<p>and afterwards you'll want to write your code in <code>src/lib.rs</code> like so:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[no_mangle]
pub extern &quot;C&quot; fn print_hello() {
    println!(&quot;Hello, world!&quot;);
}
#}</code></pre></pre>
<p>When you execute <code>cargo wasi build</code> that'll generate a <code>*.wasm</code> file which has
one exported function, <code>print_hello</code>. We can then run it via the CLI like so:</p>
<pre><code class="language-sh">$ cargo wasi build
   Compiling hello-world v0.1.0 (/home/alex/code/hello-world)
    Finished dev [unoptimized + debuginfo] target(s) in 0.08s
$ wasmtime --invoke print_hello target/wasm32-wasi/debug/hello_world.wasm
Hello, world!
</code></pre>
<p>As a library crate one of your primary consumers may be other languages as well.
You'll want to consult the <a href="./lang-python.html">section of this book for using <code>wasmtime</code> from
Python`</a> and after running through the basics there you can
execute our file in Python:</p>
<pre><code class="language-sh">$ cp target/wasm32-wasi/debug/hello_world.wasm .
$ python3
&gt;&gt;&gt; import wasmtime
&gt;&gt;&gt; import hello_world
&gt;&gt;&gt; hello_world.print_hello()
Hello, world!
()
&gt;&gt;&gt;
</code></pre>
<p>Note that this form of using <code>#[no_mangle]</code> Rust functions is pretty primitive.
You're only able to work with primitive datatypes like integers and floats.
While this works for some applications if you need to work with richer types
like strings or structs, then you'll want to use the support in <code>wasmtime</code> for
interface types.</p>
<h2><a class="header" href="#webassembly-interface-types" id="webassembly-interface-types">WebAssembly Interface Types</a></h2>
<blockquote>
<p><strong>Note</strong>: support for interface types has temporarily removed from Wasmtime.
This documentation is somewhat up to date but will no longer work with recent
versions of Wasmtime. For more information see
https://github.com/bytecodealliance/wasmtime/issues/677</p>
</blockquote>
<p>Working with WebAssembly modules at the bare-bones level means that you're only
dealing with integers and floats. Many APIs, however, want to work with things
like byte arrays, strings, structures, etc. To facilitate these interactions the
<a href="https://github.com/webassembly/interface-types">WebAssembly Interface Types
Proposal</a> comes into play. The
<code>wasmtime</code> runtime has support for interface types, and the Rust toolchain has
library support in a crate called
<a href="https://crates.io/crates/wasm-bindgen"><code>wasm-bindgen</code></a>.</p>
<blockquote>
<p><strong>Note</strong>: WebAssembly Interface Types is still a WebAssembly proposal and is
under active development. The toolchain may not match the exact specification,
and during development you'll generally need to make sure tool versions are
all kept up to date to ensure everything aligns right. This'll all smooth over
as the proposal stabilizes!</p>
</blockquote>
<p>To get started with WebAssembly interface types let's write a library
module which will generate a greeting for us. The module itself won't do any
printing, we'll simply be working with some strings.</p>
<p>To get starts let's add this to our <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[lib]
crate-type = ['cdylib']

[dependencies]
wasm-bindgen = &quot;0.2.54&quot;
</code></pre>
<p>Using this crate, we can then update our <code>src/lib.rs</code> with the following:</p>
<pre><code class="language-rust ignore">use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn greet(name: &amp;str) -&gt; String {
    format!(&quot;Hello, {}!&quot;, name)
}
</code></pre>
<p>Then we can build this with:</p>
<pre><code class="language-sh">$ cargo wasi build --release
    Updating crates.io index
...
    Finished dev [unoptimized + debuginfo] target(s) in 9.57s
 Downloading precompiled wasm-bindgen v0.2.54
</code></pre>
<p>and we have our new wasm binary!</p>
<blockquote>
<p><strong>Note</strong>: for now when using <code>wasm-bindgen</code> you must use <code>--release</code> mode to
build wasi binaries with interface types.</p>
</blockquote>
<p>We can then test out support for this with the CLI:</p>
<pre><code class="language-sh">$ wasmtime --invoke greet ./target/wasm32-wasi/release/hello_world.wasm &quot;Wasmtime CLI&quot;
warning: using `--invoke` with a function that takes arguments is experimental and may break in the future
warning: using `--invoke` with a function that returns values is experimental and may break in the future
Hello, Wasmtime CLI!
</code></pre>
<p>Here we can see some experimental warnings, but we got our error message printed
out! The first CLI parameter, <code>&quot;Wasmtime CLI&quot;</code>, was passed as the first argument
of the <code>greet</code> function. The resulting string was then printed out to the
console.</p>
<p>Like before, we can also execute this with Python:</p>
<pre><code class="language-sh">$ cp target/wasm32-wasi/release/hello_world.wasm .
$ python3
&gt;&gt;&gt; import wasmtime
&gt;&gt;&gt; import hello_world
&gt;&gt;&gt; hello_world.greet('python interpreter')
'Hello, python interpreter!'
&gt;&gt;&gt;
</code></pre>
<p>Note that <code>wasm-bindgen</code> was originally developed for JS and usage in a browser,
but a subset of its implementation (such as arguments which are strings) are
supported for WebAssembly interface types. You can also check out the <a href="https://rustwasm.github.io/wasm-bindgen/">reference
documentation for <code>wasm-bindgen</code></a> for
more information about how it works. Note that the <code>wasm-bindgen</code> support for
wasm interface type is still in its nascent phase and is likely to be greatly
improved in the future.</p>
<h2><a class="header" href="#exporting-rust-functionality" id="exporting-rust-functionality">Exporting Rust functionality</a></h2>
<p>Currently only Rust functions can be exported from a wasm module. Rust functions
must be <code>#[no_mangle]</code> to show up in the final binary, but if you're using
<code>#[wasm_bindgen]</code> that will happen automatically for you.</p>
<p>Memory is by default exported from Rust modules under the name <code>memory</code>. This
can be tweaked with the <code>-Clink-arg</code> flag to rustc to pass flags to LLD, the
WebAssembly code linker.</p>
<p>Tables cannot be imported at this time. When using <code>rustc</code> directly there is no
support for <code>anyref</code> and only one function table is supported. When using
<code>wasm-bindgen</code> it may inject an <code>anyref</code> table if necessary, but this table is
an internal detail and is not exported. The function table can be exported by
passing the <code>--export-table</code> argument to LLD (via <code>-C link-arg</code>) or can be
imported with the <code>--import-table</code>.</p>
<p>Rust currently does not have support for exporting or importing custom <code>global</code>
values.</p>
<h2><a class="header" href="#importing-host-functionality-1" id="importing-host-functionality-1">Importing host functionality</a></h2>
<p>Only functions can be imported in Rust at this time, and they can be imported
via raw interfaces like:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
# struct MyStruct;
#[link(wasm_import_module = &quot;the-wasm-import-module&quot;)]
extern &quot;C&quot; {
    // imports the name `foo` from `the-wasm-import-module`
    fn foo();

    // functions can have integer/float arguments/return values
    fn translate(a: i32) -&gt; f32;

    // Note that the ABI of Rust and wasm is somewhat in flux, so while this
    // works, it's recommended to rely on raw integer/float values where
    // possible.
    fn translate_fancy(my_struct: MyStruct) -&gt; u32;

    // you can also explicitly specify the name to import, this imports `bar`
    // instead of `baz` from `the-wasm-import-module`.
    #[link_name = &quot;bar&quot;]
    fn baz();
}
#}</code></pre></pre>
<p>When you're using <code>wasm-bindgen</code> you would instead use:</p>
<pre><code class="language-rust ignore">use wasm_bindgen::prelude::*;

#[wasm_bindgen(module = &quot;the-wasm-import-module&quot;)]
extern &quot;C&quot; {
    fn foo();
    fn baz();
    // ...
}
</code></pre>
<p>Note that unless you're using interface types you likely don't need
<code>wasm-bindgen</code>.</p>
<h1><a class="header" href="#cc" id="cc">C/C++</a></h1>
<p>All the parts needed to support wasm are included in upstream clang, lld, and
compiler-rt, as of the LLVM 8.0 release. However, to use it, you'll need
to build WebAssembly-targeted versions of the library parts, and it can
be tricky to get all the CMake invocations lined up properly.</p>
<p>To make things easier, we provide
<a href="https://github.com/WebAssembly/wasi-sdk/releases">prebuilt packages</a>
that provide builds of Clang and sysroot libraries.</p>
<p>WASI doesn't yet support <code>setjmp</code>/<code>longjmp</code> or C++ exceptions, as it is
waiting for <a href="https://github.com/WebAssembly/exception-handling/">unwinding support in WebAssembly</a>.</p>
<h1><a class="header" href="#assemblyscript" id="assemblyscript">AssemblyScript</a></h1>
<p><a href="https://assemblyscript.org">AssemblyScript</a> 0.10.0 includes support for targeting WASI. To use it, add
<code>import &quot;wasi&quot;</code> at the top of your entrypoint file.</p>
<p>To create a program which can be run directly as a command, pass <code>--runtime half</code>
to the AssemblyScript linker. This selects the <a href="https://docs.assemblyscript.org/details/runtime#runtime-variants">half runtime</a>, which ensures that
the generated wasm module doesn't contain any extraneous exports. (This isn't
strictly required today, but the handling of extraneous exports may change in
the future, so it's encouraged. As a bonus, it also reduces code size.)</p>
<p>To create a program which can be loaded as a library and used from other modules,
no special options are needed.</p>
<p>Let's walk through a simple hello world example.</p>
<h2><a class="header" href="#wasi-hello-worldts" id="wasi-hello-worldts"><code>wasi-hello-world.ts</code></a></h2>
<pre><code class="language-typescript">import &quot;wasi&quot;

import {Console} from &quot;as-wasi&quot;
Console.log('Hello World!\n');


</code></pre>
<p>This uses <a href="https://github.com/jedisct1/as-wasi">as-wasi</a> as a dependency to make working with the AssemblyScript WASI
bindings easier. Then, you can run:</p>
<pre><code class="language-sh">asc wasi-hello-world.ts -b wasi-hello-world.wasm
</code></pre>
<p>to compile it to wasm, and</p>
<pre><code class="language-sh">wasmtime wasi-hello-world.wasm
</code></pre>
<p>to run it from the command-line. Or you can instantiate it using the <a href="./lang.html">Wasmtime API</a>.</p>
<h2><a class="header" href="#packagejson" id="packagejson"><code>package.json</code></a></h2>
<p>It can also be packaged using a <code>package.json</code> file:</p>
<pre><code class="language-json">{
  &quot;name&quot;: &quot;wasi-hello-world&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;Hello world in Wasi with AS and as-wasi&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;asc wasi-hello-world.ts -b wasi-hello-world.wasm -t wasi-hello-world.wat --runtime half&quot;,
    &quot;wasmtime&quot;: &quot;wasmtime wasi-hello-world.wasm&quot;
  },
  &quot;author&quot;: &quot;Aaron Turner&quot;,
  &quot;license&quot;: &quot;MIT&quot;,
  &quot;devDependencies&quot;: {
    &quot;assemblyscript&quot;: &quot;^0.10.0&quot;
  },
  &quot;dependencies&quot;: {
    &quot;as-wasi&quot;: &quot;^0.1.1&quot;
  }
}

</code></pre>
<p>You can also <a href="https://github.com/bytecodealliance/wasmtime/blob/main/docs/assemblyscript-hello-world">browse this source code online</a> and clone the wasmtime
repository to run the example locally.</p>
<h1><a class="header" href="#webassembly-text-format-wat" id="webassembly-text-format-wat">WebAssembly Text Format (<code>*.wat</code>)</a></h1>
<p>While not necessarily a full-blown language you might be curious how Wasmtime
interacts with <a href="https://webassembly.github.io/spec/core/text/index.html">the <code>*.wat</code> text format</a>! The <code>wasmtime</code> CLI and Rust
embedding API both support the <code>*.wat</code> text format by default.</p>
<p>&quot;Hello, World!&quot; is pretty nontrivial in the <code>*.wat</code> format since it's
assembly-like and not really intended to be a primary programming language. That
being said we can create a simple add function to call it!</p>
<p>For example if you have a file <code>add.wat</code> like so:</p>
<pre><code class="language-wat">(module
  (func (export &quot;add&quot;) (param i32 i32) (result i32)
    local.get 0
    local.get 1
    i32.add))
</code></pre>
<p>Then you can execute this on the CLI with:</p>
<pre><code class="language-sh">$ wasmtime add.wat --invoke add 1 2
warning: ...
warning: ...
3
</code></pre>
<p>And we can see that we're already adding numbers!</p>
<p>You can also see how this works in the Rust API like so:</p>
<pre><pre class="playpen"><code class="language-rust"># extern crate wasmtime;
# extern crate anyhow;
use wasmtime::*;

# fn main() -&gt; anyhow::Result&lt;()&gt; {
let engine = Engine::default();
let store = Store::new(&amp;engine);
let wat = r#&quot;
  (module
    (func (export &quot;add&quot;) (param i32 i32) (result i32)
      local.get 0
      local.get 1
      i32.add))
&quot;#;
let module = Module::new(&amp;engine, wat)?;
let instance = Instance::new(&amp;store, &amp;module, &amp;[])?;
let add = instance.get_func(&quot;add&quot;).unwrap();
let add = add.get2::&lt;i32, i32, i32&gt;()?;
println!(&quot;1 + 2 = {}&quot;, add(1, 2)?);
# Ok(())
# }
</code></pre></pre>
<h1><a class="header" href="#example-markdown-parser" id="example-markdown-parser">Example: Markdown Parser</a></h1>
<h1><a class="header" href="#stability" id="stability">Stability</a></h1>
<p>... more coming soon</p>
<h1><a class="header" href="#release-process" id="release-process">Release Process</a></h1>
<p>... more coming soon</p>
<h1><a class="header" href="#platform-support" id="platform-support">Platform Support</a></h1>
<p>The <code>wasmtime</code> project is a configurable and lightweight runtime for WebAssembly
which has a number of ways it can be configured. Not all features are supported
on all platforms, but it is intended that <code>wasmtime</code> can run in some capacity on
almost all platforms! The matrix of what's being tested, what works, and what's
supported where is evolving over time, and this document hopes to capture a
snapshot of what the current state of the world looks like.</p>
<p>All features of <code>wasmtime</code> should work on the following platforms:</p>
<ul>
<li>Linux x86_64</li>
<li>Linux aarch64</li>
<li>macOS x86_64</li>
<li>Windows x86_64</li>
</ul>
<p>For more detailed information about supported platforms, please check out the
sections below!</p>
<h2><a class="header" href="#jit-compiler-support" id="jit-compiler-support">JIT compiler support</a></h2>
<p>The JIT compiler, backed by Cranelift, supports the x86_64 and aarch64
architectures at this time. Support for at least ARM and x86 is planned as well.</p>
<p>Usage of the JIT compiler will require a host operating system which supports
creating executable memory pages on-the-fly. In Rust terms this generally means
that <code>std</code> needs to be supported on this platform.</p>
<h2><a class="header" href="#interpreter-support" id="interpreter-support">Interpreter support</a></h2>
<p>At this time <code>wasmtime</code> does not have a mode in which it simply interprets
WebAssembly code. It is planned to add support for an interpreter, however, and
this will have minimal system dependencies. It is planned that the system will
need to support some form of dynamic memory allocation, but other than that not
much else will be needed.</p>
<h2><a class="header" href="#what-about-no_std" id="what-about-no_std">What about <code>#[no_std]</code>?</a></h2>
<p>The <code>wasmtime</code> project does not currently use <code>#[no_std]</code> for its crates, but
this is not because it won't support it! At this time we're still gathering use
cases for for what <code>#[no_std]</code> might entail, so if you're interested in this
we'd love to hear about your use case! Feel free to <a href="https://github.com/bytecodealliance/wasmtime/issues/new">open an
issue</a> on the
<code>wasmtime</code> repository to discuss this.</p>
<p>This is a common question we are asked, however, so to provide some more context
on why Wasmtime is the way it is, here's some responses to frequent points
raised about <code>#![no_std]</code>:</p>
<ul>
<li>
<p><strong>What if my platform doesn't have <code>std</code>?</strong> - For platforms without support
for the Rust standard library the JIT compiler of Wasmtime often won't run on
the platform as well. The JIT compiler requires <code>mmap</code> (or an equivalent), and
presence of <code>mmap</code> often implies presence of a libc which means Rust's <code>std</code>
library works.</p>
<p>Cargo's <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#build-std"><code>-Z build-std</code> feature</a> feature is also intended to help
easily build the standard library for all platforms. With this feature you can
recompile the standard library (using Nightly Rust for now) with a <a href="https://doc.rust-lang.org/rustc/targets/custom.html">custom
target specification</a> if necessary. Additionally the intention
at this time is to get <code>std</code> building for all platforms, regardless of what
the platform actually supports. This change is taking time to implement, but
<a href="https://github.com/rust-lang/rust/pull/74033">rust-lang/rust#74033</a> is an example of this support growing over time.</p>
<p>We're also interested in running Wasmtime without a JIT compiler in the
future, but that is not implemented at this time. Implementing this will
require a lot more work than tagging crates <code>#![no_std]</code>. The Wasmtime
developers are also very interested in supporting as many targets as possible,
so if Wasmtime doesn't work on your platform yet we'd love to learn why and
what we can do to support that platform, but the conversation here is
typically more nuanced than simply making <code>wasmtime</code> compile without <code>std</code>.</p>
</li>
<li>
<p><strong>Doesn't <code>#![no_std]</code> have smaller binary sizes?</strong> - There's a lot of factors
that affect binary size in Rust. Compilation options are a huge one but beyond
that idioms and libraries linked matter quite a lot as well. Code is not
inherently large when using <code>std</code> instead of <code>core</code>, it's just that often code
using <code>std</code> has more dependencies (like <code>std::thread</code>) which requires code to
bind. Code size improvements can be made to code using <code>std</code> and <code>core</code>
equally, and switching to <code>#![no_std]</code> is not a silver bullet for compile
sizes.</p>
</li>
<li>
<p><strong>The patch to switch to <code>#![no_std]</code> is small, why not accept it?</strong> - PRs to
switch to <code>#![no_std]</code> are often relatively small or don't impact too many
parts of the system. There's a lot more to developing a <code>#![no_std]</code>
WebAssembly runtime than switching a few crates, however. Maintaining a
<code>#![no_std]</code> library over time has a number of costs associated with it:</p>
<ul>
<li>
<p>Rust has no stable way to diagnose <code>no_std</code> errors in an otherwise <code>std</code>
build, which means that to supoprt this feature it must be tested on CI with
a <code>no_std</code> target. This is costly in terms of CI time, CI maintenance, and
developers having to do extra builds to avoid CI errors. Note that this
isn't <em>more</em> costly than any other platform supported by Wasmtime, but it's
a cost nonetheless.</p>
</li>
<li>
<p>Idioms in <code>#![no_std]</code> are quite different than normal Rust code. You'll
import from different crates (<code>core</code> instead of <code>std</code>) and data structures
have to all be manually imported from <code>alloc</code>. These idioms are difficult to
learn for newcomers to the project and are not well documented in the
ecosystem. This cost of development and maintenance is not unique to
Wasmtime but in general affects the <code>#![no_std]</code> ecosystem at large,
unfortunately.</p>
</li>
<li>
<p>Currently Wasmtime does not have a target use case which requires
<code>#![no_std]</code> support, so it's hard to justify these costs of development.
We're very interested in supporting as many use cases and targets as
possible, but the decision to support a target needs to take into account
the costs associated so we can plan accordingly. Effectively we need to have
a goal in mind instead of taking on the costs of <code>#![no_std]</code> blindly.</p>
</li>
<li>
<p>At this time it's not clear whether <code>#![no_std]</code> will be needed long-term,
so eating short-term costs may not pay off in the long run. Features like
Cargo's <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#build-std"><code>-Z build-std</code></a> may mean that <code>#![no_std]</code> is less and
less necessary over time.</p>
</li>
</ul>
</li>
<li>
<p><strong>How can Wasmtime support <code>#![no_std]</code> if it uses X?</strong> - Wasmtime as-is today
is not suitable for many <code>#![no_std]</code> contexts. For example it might use
<code>mmap</code> for allocating JIT code memory, leverage threads for caching, or use
thread locals when calling into JIT code. These features are difficult to
support in their full fidelity on all platforms, but the Wasmtime developers
are very much aware of this! Wasmtime is intended to be configurable where
many of these features are compile-time or runtime options. For example caches
can be disabled, JITs can be removed and replaced with interpreters, or users
could provide a callback to allocate memory instead of using the OS.
This is sort of a long-winded way of saying that Wasmtime on the surface may
today look like it won't support <code>#![no_std]</code>, but this is almost always
simply a matter of time and development priorities rather than a fundamental
reason why Wasmtime <em>couldn't</em> support <code>#![no_std]</code>.</p>
</li>
</ul>
<p>Note that at this time these guidelines apply not only to Wasmtime but also to
some of its dependencies developed by the Bytecode Alliance such as the
<a href="https://github.com/bytecodealliance/wasm-tools">wasm-tools repository</a>. These
projects don't have the same runtime requirements as Wasmtime (e.g. <code>wasmparser</code>
doesn't need <code>mmap</code>), but we're following the same guidelines above at this
time. Patches to add <code>#![no_std]</code>, while possibly small, incur many of the same
costs and also have an unclear longevity as features like <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#build-std"><code>-Z build-std</code></a> evolve.</p>
<h1><a class="header" href="#webassembly-proposals-support" id="webassembly-proposals-support">WebAssembly Proposals Support</a></h1>
<p>The following table summarizes Wasmtime's support for WebAssembly proposals as
well as the command line flag and <a href="https://docs.rs/wasmtime/*/wasmtime/struct.Config.html"><code>wasmtime::Config</code></a> method you can
use to enable or disable support for a proposal.</p>
<p>If a proposal is not listed, then it is not supported by Wasmtime.</p>
<p>Wasmtime will never enable a proposal by default unless it has reached phase 4
of <a href="https://github.com/WebAssembly/meetings/blob/master/process/phases.md">the WebAssembly standardizations process</a> and its implementation in
Wasmtime has been <a href="./contributing-implementing-wasm-proposals.html">thoroughly
vetted</a>.</p>
<table><thead><tr><th>WebAssembly Proposal</th><th>Supported in Wasmtime?</th><th>Command Line Flag</th><th><a href="https://docs.rs/wasmtime/*/wasmtime/struct.Config.html"><code>Config</code></a> Method</th></tr></thead><tbody>
<tr><td><strong><a href="https://github.com/WebAssembly/mutable-global/blob/master/proposals/mutable-global/Overview.md">Import and Export Mutable Globals</a></strong></td><td><strong>Yes.</strong><br/>Always enabled.</td><td>(none)</td><td>(none)</td></tr>
<tr><td><strong><a href="https://github.com/WebAssembly/spec/blob/master/proposals/sign-extension-ops/Overview.md">Sign-Extension Operations</a></strong></td><td><strong>Yes.</strong><br/>Always enabled.</td><td>(none)</td><td>(none)</td></tr>
<tr><td><strong><a href="https://github.com/WebAssembly/spec/blob/master/proposals/nontrapping-float-to-int-conversion/Overview.md">Non-Trapping Float-to-Int Conversions</a></strong></td><td><strong>Yes.</strong><br/>Always enabled.</td><td>(none)</td><td>(none)</td></tr>
<tr><td><strong><a href="https://github.com/WebAssembly/spec/blob/master/proposals/multi-value/Overview.md">Multi-Value</a></strong></td><td><strong>Yes.</strong><br/>Enabled by default.</td><td><code>--enable-multi-value</code></td><td><a href="https://docs.rs/wasmtime/*/wasmtime/struct.Config.html#method.wasm_multi_value"><code>wasm_multi_value</code></a></td></tr>
<tr><td><strong><a href="https://github.com/WebAssembly/bulk-memory-operations/blob/master/proposals/bulk-memory-operations/Overview.md">Bulk Memory Operations</a></strong></td><td><strong>Yes.</strong><br/>Enabled by default.</td><td><code>--enable-bulk-memory</code></td><td><a href="https://docs.rs/wasmtime/*/wasmtime/struct.Config.html#method.wasm_bulk_memory"><code>wasm_bulk_memory</code></a></td></tr>
<tr><td><strong><a href="https://github.com/WebAssembly/reference-types/blob/master/proposals/reference-types/Overview.md">Reference Types</a></strong></td><td><strong>Yes.</strong><br/>Enabled by default on x86_64. Aarch64 support in progress.</td><td><code>--enable-reference-types</code></td><td><a href="https://docs.rs/wasmtime/*/wasmtime/struct.Config.html#method.wasm_reference_types"><code>wasm_reference_types</code></a></td></tr>
<tr><td><strong><a href="https://github.com/WebAssembly/simd/blob/master/proposals/simd/SIMD.md">Fixed-Width SIMD</a></strong></td><td><strong>In progress.</strong></td><td><code>--enable-simd</code></td><td><a href="https://docs.rs/wasmtime/*/wasmtime/struct.Config.html#method.wasm_simd"><code>wasm_simd</code></a></td></tr>
<tr><td><strong><a href="https://github.com/WebAssembly/threads/blob/master/proposals/threads/Overview.md">Threads and Atomics</a></strong></td><td><strong>In progress.</strong></td><td><code>--enable-threads</code></td><td><a href="https://docs.rs/wasmtime/*/wasmtime/struct.Config.html#method.wasm_threads"><code>wasm_threads</code></a></td></tr>
</tbody></table>
<h1><a class="header" href="#security" id="security">Security</a></h1>
<p>... more coming soon</p>
<h1><a class="header" href="#disclosure-policy" id="disclosure-policy">Disclosure Policy</a></h1>
<p>... more coming soon</p>
<h1><a class="header" href="#sandboxing" id="sandboxing">Sandboxing</a></h1>
<p>One of WebAssembly (and Wasmtime's) main goals is to execute untrusted code in
a safe manner inside of a sandbox. WebAssembly is inherently sandboxed by design
(must import all functionality, etc). This document is intended to cover the
various sandboxing implementation strategies that Wasmtime has as they are
developed.</p>
<p>At this time Wasmtime implements what's necessary for the WebAssembly
specification, for example memory isolation between instances. Additionally the
safe Rust API is intended to mitigate accidental bugs in hosts.</p>
<p>Different sandboxing implementation techniques will also come with different
tradeoffs in terms of performance and feature limitations, and Wasmtime plans to
offer users choices of which tradeoffs they want to make.</p>
<p>More will be added here over time!</p>
<h2><a class="header" href="#webassembly-core" id="webassembly-core">WebAssembly Core</a></h2>
<p>The core WebAssembly spec has several features which create a unique sandboxed
environment:</p>
<ul>
<li>
<p>The callstack is inaccessible. Unlike most native execution environments,
return addresses from calls and spilled registers are not stored in memory
accessible to applications. They are stored in memory that only the
implementation has access to, which makes traditional stack-smashing attacks
targeting return addresses impossible.</p>
</li>
<li>
<p>Pointers, in source languages which have them, are compiled to offsets
into linear memory, so implementations details such as virtual addresses
are hidden from applications. And all accesses within linear memory are
checked to ensure they stay in bounds.</p>
</li>
<li>
<p>All control transfers—direct and indirect branches, as well as direct and
indirect calls—are to known and type-checked destinations, so it's not
possible to accidentally call into the middle of a function or branch
outside of a function.</p>
</li>
<li>
<p>All interaction with the outside world is done through imports and exports.
There is no raw access to system calls or other forms of I/O; the only
thing a WebAssembly instance can do is what is available through interfaces
it has been explicitly linked with.</p>
</li>
<li>
<p>There is no undefined behavior. Even where the WebAssembly spec permits
multiple possible behaviors, it doesn't permit arbitrary behavior.</p>
</li>
</ul>
<h2><a class="header" href="#filesystem-access" id="filesystem-access">Filesystem Access</a></h2>
<p>Wasmtime implements the WASI APIs for filesystem access, which follow a
capability-based security model, which ensures that applications can only
access files and directories they've been given access to. WASI's security
model keeps users safe today, and also helps us prepare for shared-nothing
linking and nanoprocesses in the future.</p>
<p>Wasmtime developers are intimately engaged with the WASI standards process,
libraries, and tooling development, all along the way too.</p>
<h2><a class="header" href="#terminal-output" id="terminal-output">Terminal Output</a></h2>
<p>If untrusted code is allowed to print text which is displayed to a terminal, it may
emit ANSI-style escape sequences and other control sequences which, depending on
the terminal the user is using and how it is configured, can have side effects
including writing to files, executing commands, injecting text into the stream
as if the user had typed it, or reading the output of previous commands. ANSI-style
escape sequences can also confuse or mislead users, making other vulnerabilities
easier to exploit.</p>
<p>Our first priority is to protect users, so Wasmtime now filters writes to output
streams when they are connected to a terminal to translate escape sequences into
inert replacement sequences.</p>
<p>Some applications need ANSI-style escape sequences, such as terminal-based
editors and programs that use colors, so we are also developing a proposal for
the WASI Subgroup for safe and portable ANSI-style escape sequence support, which
we hope to post more about soon.</p>
<h2><a class="header" href="#spectre" id="spectre">Spectre</a></h2>
<p>Wasmtime does not yet implement Spectre mitigations, however this is a subject
of ongoing research.</p>
<h1><a class="header" href="#contributing" id="contributing">Contributing</a></h1>
<p>We're excited to work on Wasmtime and/or Cranelift together with you! This guide
should help you get up and running with Wasmtime and Cranelift development. But
first, make sure you've read the <a href="./contributing-coc.html">Code of Conduct</a>!</p>
<p>Wasmtime and Cranelift are very ambitious projects with many goals, and while
we're confident we can achieve some of them, we see many opportunities for
people to get involved and help us achieve even more.</p>
<h2><a class="header" href="#join-our-chat" id="join-our-chat">Join Our Chat</a></h2>
<p>We chat about Wasmtime and Cranelift development on Zulip — <a href="https://bytecodealliance.zulipchat.com/">join
us!</a>. You can also join specific
streams:</p>
<ul>
<li><a href="https://bytecodealliance.zulipchat.com/#narrow/stream/217126-wasmtime">#wasmtime</a></li>
<li><a href="https://bytecodealliance.zulipchat.com/#narrow/stream/217117-cranelift">#cranelift</a></li>
</ul>
<p>If you're having trouble building Wasmtime or Cranelift, aren't sure why a test
is failing, or have any other questions, feel free to ask on Zulip. Not
everything we hope to do with these projects is reflected in the code or
documentation yet, so if you see things that seem missing or that don't make
sense, or even that just don't work the way you expect them to, we're also
interested to hear about that!</p>
<p>As always, you're more than welcome to <a href="https://github.com/bytecodealliance/wasmtime/issues/new">open an
issue</a> too!</p>
<h2><a class="header" href="#finding-something-to-hack-on" id="finding-something-to-hack-on">Finding Something to Hack On</a></h2>
<p>If you're looking for something to do, these are great places to start:</p>
<ul>
<li>
<p><a href="https://github.com/bytecodealliance/wasmtime/labels/good%20first%20issue">Issues labeled &quot;good first
issue&quot;</a>
— these issues tend to be simple, what needs to be done is well known,
and are good for new contributors to tackle. The goal is to learn Wasmtime's
development workflow and make sure that you can build and test Wasmtime.</p>
</li>
<li>
<p><a href="https://github.com/bytecodealliance/wasmtime/labels/help%20wanted">Issues labeled &quot;help
wanted&quot;</a>
— these are issues that we need a little help with!</p>
</li>
</ul>
<p>If you're unsure if an issue is a good fit for you or not, feel free to ask in a
comment on the issue, or in chat.</p>
<h3><a class="header" href="#mentoring" id="mentoring">Mentoring</a></h3>
<p>We're happy to mentor people, whether you're learning Rust, learning about
compiler backends, learning about machine code, learning about wasm, learning
about how Cranelift does things, or all together at once.</p>
<p>We categorize issues in the issue tracker using a tag scheme inspired by
<a href="https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#issue-triage">Rust's issue tags</a>. For example, the <a href="https://github.com/bytecodealliance/wasmtime/labels/cranelift%3AE-easy">E-easy</a> marks good beginner issues,
and <a href="https://github.com/bytecodealliance/wasmtime/labels/cranelift%3AE-rust">E-rust</a> marks issues which likely require some familiarity with Rust,
though not necessarily Cranelift-specific or even compiler-specific
experience. <a href="https://github.com/bytecodealliance/wasmtime/labels/cranelift%3AE-compiler-easy">E-compiler-easy</a> marks issues good for beginners who have
some familiarity with compilers, or are interested in gaining some :-).</p>
<p>See also the <a href="https://github.com/bytecodealliance/wasmtime/labels?q=cranelift">full list of Cranelift labels</a>.</p>
<p>Also, we encourage people to just look around and find things they're
interested in. This a good time to get involved, as there aren't a lot of
things set in stone yet.</p>
<h1><a class="header" href="#building" id="building">Building</a></h1>
<p>This section describes everything required to build and run Wasmtime.</p>
<h2><a class="header" href="#prerequisites" id="prerequisites">Prerequisites</a></h2>
<p>Before we can actually build Wasmtime, we'll need to make sure these things are
installed first.</p>
<h3><a class="header" href="#git-submodules" id="git-submodules">Git Submodules</a></h3>
<p>The Wasmtime repository contains a number of git submodules. To build Wasmtime
and most other crates in the repository, you have to ensure that those are
initialized with this command:</p>
<pre><code class="language-shell">git submodule update --init
</code></pre>
<h3><a class="header" href="#the-rust-toolchain" id="the-rust-toolchain">The Rust Toolchain</a></h3>
<p><a href="https://www.rust-lang.org/tools/install">Install the Rust toolchain here.</a> This
includes <code>rustup</code>, <code>cargo</code>, <code>rustc</code>, etc...</p>
<h3><a class="header" href="#libclang-optional" id="libclang-optional"><code>libclang</code> (optional)</a></h3>
<p>The <code>wasmtime-fuzzing</code> crate transitively depends on <code>bindgen</code>, which requires
that your system has a <code>libclang</code> installed. Therefore, if you want to hack on
Wasmtime's fuzzing infrastructure, you'll need <code>libclang</code>. <a href="https://rust-lang.github.io/rust-bindgen/requirements.html#clang">Details on how to
get <code>libclang</code> and make it available for <code>bindgen</code> are
here.</a></p>
<h2><a class="header" href="#building-the-wasmtime-cli" id="building-the-wasmtime-cli">Building the <code>wasmtime</code> CLI</a></h2>
<p>To make an unoptimized, debug build of the <code>wasmtime</code> CLI tool, go to the root
of the repository and run this command:</p>
<pre><code class="language-shell">cargo build
</code></pre>
<p>The built executable will be located at <code>target/debug/wasmtime</code>.</p>
<p>To make an optimized build, run this command in the root of the repository:</p>
<pre><code class="language-shell">cargo build --release
</code></pre>
<p>The built executable will be located at <code>target/release/wasmtime</code>.</p>
<p>You can also build and run a local <code>wasmtime</code> CLI by replacing <code>cargo build</code>
with <code>cargo run</code>.</p>
<h2><a class="header" href="#building-the-wasmtime-c-api" id="building-the-wasmtime-c-api">Building the Wasmtime C API</a></h2>
<p>To build the C API of Wasmtime you can run:</p>
<pre><code class="language-shell">cargo build --release --manifest-path crates/c-api/Cargo.toml
</code></pre>
<p>This will place the shared library inside of <code>target/release</code>. On Linux it will
be called <code>libwasmtime.{a,so}</code>, on macOS it will be called
<code>libwasmtime.{a,dylib}</code>, and on Windows it will be called
<code>wasmtime.{lib,dll,dll.lib}</code>.</p>
<h2><a class="header" href="#building-other-wasmtime-crates" id="building-other-wasmtime-crates">Building Other Wasmtime Crates</a></h2>
<p>You can build any of the Wasmtime crates by appending <code>-p wasmtime-whatever</code> to
the <code>cargo build</code> invocation. For example, to build the <code>wasmtime-jit</code> crate,
execute this command:</p>
<pre><code class="language-shell">cargo build -p wasmtime-jit
</code></pre>
<p>Alternatively, you can <code>cd</code> into the crate's directory, and run <code>cargo build</code>
there, without needing to supply the <code>-p</code> flag:</p>
<pre><code class="language-shell">cd crates/jit/
cargo build
</code></pre>
<h2><a class="header" href="#cross-compiling-wasmtime" id="cross-compiling-wasmtime">Cross Compiling Wasmtime</a></h2>
<p>By default <code>cargo build</code> will build Wasmtime for the platform you're running the
build on. You might, however, want to build Wasmtime for a different platform!
Let's say for example that you want to build Wasmtime for
<code>aarch64-unknown-linux-gnu</code>. First you'll want to acquire the Rust standard
library for this target:</p>
<pre><code class="language-shell">rustup target add aarch64-unknown-linux-gnu
</code></pre>
<p>Next you need to install a native C toolchain which has a C compiler, runtime
libraries, and linker for the desired target. This is unfortunately not very
easy to acquire on most platforms:</p>
<ul>
<li>
<p>On Windows you can install build tools for AArch64 Windows, but targeting
platforms like Linux or macOS is not easy. While toolchains exist for
targeting non-Windows platforms you'll have to hunt yourself to find the right
one.</p>
</li>
<li>
<p>On macOS you can install, through Xcode, toolchains for iOS but the main
<code>x86_64-apple-darwin</code> is really the only easy target to install. You'll need
to hunt for toolchains if you want to compile for Linux or Windows.</p>
</li>
<li>
<p>On Linux you can relatively easily compile for other Linux architectures most
of the time. For example on Debian-based distributions you can install the
<code>gcc-aarch64-linux-gnu</code> package which should come with the C compiler, runtime
libraries, and linker all in one (assuming you don't explicitly request
disabling recommended packages). Other Linux distributions may have
differently named toolchains. Compiling for macOS from Linux will require
finding your own toolchain. Compiling for Windows MSVC will require finding
your own toolchain, but compiling for MinGW can work easily enough if you
install the MinGW toolchain via your package manager.</p>
</li>
</ul>
<p>For now we'll assume you're on Linux compiling for a different Linux
architecture.  Once you've got the native toolchain, you'll want to find the C
compiler that came with it. On Debian, for example, this is called
<code>aarch64-linux-gnu-gcc</code>. Next up you'll need to configure two environment
variables to configure the Rust build:</p>
<pre><code class="language-shell">export CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc
export CC_aarch64_unknown_linux_gnu=aarch64-linux-gnu-gcc
</code></pre>
<p>The first environment variable tells Cargo to tell rustc what the correct linker
for your target is. The second configures the <a href="https://crates.io/crates/cc"><code>cc</code> Rust
crate</a> for C code compiled as part of the build.</p>
<p>Finally you can execute.</p>
<pre><code class="language-shell">cargo build --target aarch64-unknown-linux-gnu --release
</code></pre>
<p>The built executable will be located at
<code>target/aarch64-unknown-linux-gnu/release/wasmtime</code>. Note that you can
cross-compile the C API in the same manner as the CLI too.</p>
<p>Note that if you are using these invocations regularly, you can avoid the need
to set environment variables by adding some configuration to your persistent
Cargo configuration. In the file <code>~/.cargo/config.toml</code> (in your home
directory), add the section:</p>
<pre><code class="language-plain">[target.aarch64-unknown-linux-gnu]
linker = 'aarch64-linux-gnu-gcc'
</code></pre>
<p>Then the above <code>cargo build --target aarch64-unknown-linux-gnu</code> command should
work without setting any extra environment variables beforehand.</p>
<h2><a class="header" href="#running-a-cross-compiled-wasmtime-in-qemu-emulation" id="running-a-cross-compiled-wasmtime-in-qemu-emulation">Running a Cross-Compiled Wasmtime in qemu (emulation)</a></h2>
<p>Once you have cross-compiled a binary, it is possible to run it on an emulator
if you do not have access to (or do not wish to use) hardware with the given
architecture. This can be done using an emulator such as <code>qemu</code>. The <code>qemu</code>
user-space emulation support allows running, for example, a Linux/aarch64
binary on a Linux/x86-64 host, as long as you have the system libraries for
aarch64 as well.</p>
<p>To try this out, first install <code>qemu</code>, making sure that the user-space emulator
option for your target architecture is enabled. On Debian-based Linux
distributions (including Ubuntu), this is in the <code>qemu-user</code> package, for
example.</p>
<p>Next, make sure that you have system libraries for the target. You will already
have these present if you cross-compiled as described above.</p>
<p>Finally, you can run the <code>wasmtime</code> binary under <code>qemu</code>; the following example
is for an <code>aarch64</code> target. Adjust the library paths as appropriate; these are
correct for Ubuntu/Debian's cross-compilation packages.</p>
<pre><code class="language-shell">qemu-aarch64 \
  -L /usr/aarch64-linux-gnu \
  -E LD_LIBRARY_PATH=/usr/aarch64-linux-gnu/lib \
  target/aarch64-unknown-linux-gnu/release/wasmtime [ARGS]
</code></pre>
<p>You can add this to your persistent Cargo configuration as well. Extending the
above example in <code>~/.cargo/config.toml</code>, you can add:</p>
<pre><code class="language-plain">[target.aarch64-unknown-linux-gnu]
linker = 'aarch64-linux-gnu-gcc'
runner = &quot;qemu-aarch64 -L /usr/aarch64-linux-gnu -E LD_LIBRARY_PATH=/usr/aarch64-linux-gnu/lib&quot;
</code></pre>
<p>Then a simple <code>cargo test --target aarch64-unknown-linux-gnu</code> should work.</p>
<h1><a class="header" href="#testing" id="testing">Testing</a></h1>
<p>This section describes how to run Wasmtime's tests and add new tests.</p>
<p>Before continuing, make sure you can <a href="./contributing-building.html">build
Wasmtime</a> successfully. Can't run the tests if you
can't build it!</p>
<h2><a class="header" href="#running-all-tests" id="running-all-tests">Running All Tests</a></h2>
<p>To run all of Wasmtime's tests (excluding WASI integration tests), execute this command:</p>
<pre><code class="language-shell">cargo test --all
</code></pre>
<p>To include WASI integration tests, you'll need <code>wasm32-wasi</code> target installed, which,
assuming you're using <a href="https://rustup.rs">rustup.rs</a> to manage your Rust versions,
can be done as follows:</p>
<pre><code class="language-shell">rustup target add wasm32-wasi
</code></pre>
<p>Next, to run all tests including the WASI integration tests, execute this command:</p>
<pre><code class="language-shell">cargo test --features test-programs/test_programs --all
</code></pre>
<p>You can also exclude a particular crate from testing with <code>--exclude</code>. For
example, if you want to avoid testing the <code>wastime-fuzzing</code> crate — which
requires that <code>libclang</code> is installed on your system, and for some reason maybe
you don't have it — you can run:</p>
<pre><code class="language-shell">cargo test --all --exclude wasmtime-fuzzing
</code></pre>
<h2><a class="header" href="#testing-a-specific-crate" id="testing-a-specific-crate">Testing a Specific Crate</a></h2>
<p>You can test a particular Wasmtime crate with <code>cargo test -p wasmtime-whatever</code>. For example, to test the <code>wasmtime-environ</code> crate, execute
this command:</p>
<pre><code class="language-shell">cargo test -p wasmtime-environ
</code></pre>
<p>Alternatively, you can <code>cd</code> into the crate's directory, and run <code>cargo test</code>
there, without needing to supply the <code>-p</code> flag:</p>
<pre><code class="language-shell">cd crates/environ/
cargo test
</code></pre>
<h2><a class="header" href="#running-the-wasm-spec-tests" id="running-the-wasm-spec-tests">Running the Wasm Spec Tests</a></h2>
<p>The spec testsuite itself is in a git submodule, so make sure you've
checked it out and initialized its submodule:</p>
<pre><code class="language-shell">git submodule update --init
</code></pre>
<p>When the submodule is checked out, Wasmtime runs the Wasm spec testsuite as part
of testing the <code>wasmtime-cli</code> crate:</p>
<pre><code class="language-shell">cargo test -p wasmtime-cli
</code></pre>
<h2><a class="header" href="#running-wasi-integration-tests-only" id="running-wasi-integration-tests-only">Running WASI Integration Tests Only</a></h2>
<p>WASI integration tests can be run separately from all other tests which
can be useful when working on the <code>wasi-common</code> crate. This can be done by
executing this command:</p>
<pre><code class="language-shell">cargo test --features test-programs/test_programs -p test-programs
</code></pre>
<h2><a class="header" href="#adding-new-tests" id="adding-new-tests">Adding New Tests</a></h2>
<h3><a class="header" href="#adding-rusts-test-style-tests" id="adding-rusts-test-style-tests">Adding Rust's <code>#[test]</code>-Style Tests</a></h3>
<p>For very &quot;unit-y&quot; tests, we add <code>test</code> modules in the same <code>.rs</code> file as the
code that is being tested. These <code>test</code> modules are configured to only get
compiled during testing with <code>#[cfg(test)]</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// some code...

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn some_test_for_that_code() {
        // ...
    }
}
#}</code></pre></pre>
<p>If you're writing a unit test and a <code>test</code> module doesn't already exist, you can
create one.</p>
<p>For more &quot;integration-y&quot; tests, we create a <code>tests</code> directory within the crate,
and put the tests inside there. For example, there are various code
cache-related tests at <code>crates/environ/tests/cache_*.rs</code>. Always feel free to
add a <code>tests</code> directory to a crate, if you want to add a new test and there
aren't any existing tests.</p>
<h3><a class="header" href="#adding-specification-style-wast-tests" id="adding-specification-style-wast-tests">Adding Specification-Style Wast Tests</a></h3>
<p>We use the spec testsuite as-is and without custom patches or a forked
version. This probably isn't what you want to modify when adding a new Wasmtime
test!</p>
<p>When you have a Wasmtime-specific test that you'd like to write in Wast and use
the Wast-style assertions, you can add it to our &quot;misc testsuite&quot;. The misc
testsuite uses the same syntax and assertions as the spec testsuite, but lives
in <code>tests/misc_testsuite</code>. Feel free to add new tests to existing
<code>tests/misc_testsuite/*.wast</code> files or create new ones as needed. These tests
are run as part of the <code>wasmtime-cli</code> crate's tests.</p>
<p>If you have a new test that you think really belongs in the spec testsuite, make
sure it makes sense for every Wasm implementation to run your test (i.e. it
isn't Wasmtime-specific) and send a pull request
<a href="https://github.com/WebAssembly/testsuite/">upstream</a>. Once it is accepted in
the upstream repo, we can update our git submodule and we'll start running the
new tests.</p>
<h3><a class="header" href="#adding-wasi-integration-tests" id="adding-wasi-integration-tests">Adding WASI Integration Tests</a></h3>
<p>When you have a WASI-specific test program that you'd like to include as a
test case to run against our WASI implementation, you can add it to our
<code>test-programs</code> crate. In particular, you should drop a main-style Rust source
file into <code>crates/test-programs/wasi-tests/src/bin/some_new_test.rs</code> with a
name of your choice. And that's it! The build script included in the
<code>test-programs</code> crate will automatically generate the necessary boilerplate
code for your test program so that it's run on all supported hosts.</p>
<p>If you would like to tweak which host to run the test program against however
(for instance, only on Unix but on Windows), you can tweak that in the build
script located under <code>crates/test-programs/build.rs</code>.</p>
<h1><a class="header" href="#fuzzing" id="fuzzing">Fuzzing</a></h1>
<h2><a class="header" href="#test-case-generators-and-oracles" id="test-case-generators-and-oracles">Test Case Generators and Oracles</a></h2>
<p>Test case generators and oracles live in the <code>wasmtime-fuzzing</code> crate, located
in the <code>crates/fuzzing</code> directory.</p>
<p>A <em>test case generator</em> takes raw, unstructured input from a fuzzer and
translates that into a test case. This might involve interpreting the raw input
as &quot;DNA&quot; or pre-determined choices through a decision tree and using it to
generate an in-memory data structure, or it might be a no-op where we interpret
the raw bytes as if they were Wasm.</p>
<p>An <em>oracle</em> takes a test case and determines whether we have a bug. For example,
one of the simplest oracles is to take a Wasm binary as an input test case,
validate and instantiate it, and (implicitly) check that no assertions failed or
segfaults happened. A more complicated oracle might compare the result of
executing a Wasm file with and without optimizations enabled, and make sure that
the two executions are observably identical.</p>
<p>Our test case generators and oracles strive to be fuzzer-agnostic: they can be
reused with libFuzzer or AFL or any other fuzzing engine or driver.</p>
<h2><a class="header" href="#libfuzzer-and-cargo-fuzz-fuzz-targets" id="libfuzzer-and-cargo-fuzz-fuzz-targets">libFuzzer and <code>cargo fuzz</code> Fuzz Targets</a></h2>
<p>We combine a test case generator and one more more oracles into a <em>fuzz
target</em>. Because the target needs to pipe the raw input from a fuzzer into the
test case generator, it is specific to a particular fuzzer. This is generally
fine, since they're only a couple of lines of glue code.</p>
<p>Currently, all of our fuzz targets are written for
<a href="https://www.llvm.org/docs/LibFuzzer.html">libFuzzer</a> and <a href="https://rust-fuzz.github.io/book/cargo-fuzz.html"><code>cargo fuzz</code></a>. They are defined in
the <code>fuzz</code> subdirectory.</p>
<p>See
<a href="https://github.com/bytecodealliance/wasmtime/blob/main/fuzz/README.md"><code>fuzz/README.md</code></a>
for details on how to run these fuzz targets and set up a corpus of seed inputs.</p>
<h1><a class="header" href="#continuous-integration-ci" id="continuous-integration-ci">Continuous Integration (CI)</a></h1>
<p>The Wasmtime and Cranelift projects heavily rely on Continuous Integration (CI)
to ensure everything keeps working and keep the final end state of the code at
consistently high quality. The CI setup for this repository is relatively
involved and extensive, and so it's worth covering here how it's organized and
what's expected of contributors.</p>
<p>All CI currently happens on GitHub Actions and is configured in the <a href="https://github.com/bytecodealliance/wasmtime/tree/main/.github"><code>.github</code>
directory</a> of the repository.</p>
<h2><a class="header" href="#prs-and-ci" id="prs-and-ci">PRs and CI</a></h2>
<p>Currently the full CI test suite runs on every Pull Request. All PRs need to
have that lovely green checkmark before being candidates for being merged. If a
test is failing you'll want to check out the logs on CI and fix it before the PR
can be merged.</p>
<p>PR authors are expected to fix CI failures in their PR, unless the CI failure is
systemic and unrelated to the PR. In that case other maintainers should be
alerted to ensure that the problem can be addressed.</p>
<h2><a class="header" href="#tests-run-on-ci" id="tests-run-on-ci">Tests run on CI</a></h2>
<p>While this may not be fully exhaustive, the general idea of all the checks we
run on CI looks like this:</p>
<ul>
<li>
<p>Code formatting - we run <code>cargo fmt -- --check</code> on CI to ensure that all code
in the repository is formatted with rustfmt. All PRs are expected to be
formatted with the latest stable version of rustfmt.</p>
</li>
<li>
<p>Book documentation tests - code snippets (Rust ones at least) in the book
documentation (<a href="https://github.com/bytecodealliance/wasmtime/tree/main/docs">the <code>docs</code>
folder</a>) are
tested on CI to ensure they are working.</p>
</li>
<li>
<p>Crate tests - the moral equivalent of <code>cargo test --all</code> and <code>cargo test --all --release</code> is executed on CI. This means that all workspace crates have their
entire test suite run, documentation tests and all, in both debug and release
mode. Additionally we execute all crate tests on macOS, Windows, and Linux, to
ensure that everything works on all the platforms.</p>
</li>
<li>
<p>Fuzz regression tests - we take a random sampling of the <a href="https://github.com/bytecodealliance/wasmtime-libfuzzer-corpus">fuzz
corpus</a> and run
it through the fuzzers. This is mostly intended to be a pretty quick
regression test and testing the fuzzers still build, most of our fuzzing
happens on <a href="https://oss-fuzz.com">oss-fuzz</a>.</p>
</li>
</ul>
<p>While we do run more tests here and there, this is the general shape of what you
can be expected to get tested on CI for all commits and all PRs. You can of
course always feel free to expand our CI coverage by editing the CI files
themselves, we always like to run more tests!</p>
<h2><a class="header" href="#artifacts-produced-on-ci" id="artifacts-produced-on-ci">Artifacts produced on CI</a></h2>
<p>Our CI system is also responsible for producing all binary releases and
documentation of Wasmtime and Cranelift. Currently this consists of:</p>
<ul>
<li>
<p>Tarballs of the <code>wasmtime</code> CLI - produced for macOS, Windows, and Linux we try
to make these &quot;binary compatible&quot; wherever possible, for example producing the
Linux build in a really old CentOS container to have a very low glibc
requirement.</p>
</li>
<li>
<p>Tarballs of the Python extension - also produced on the main three platforms
these wheels are compiled on each commit.</p>
</li>
<li>
<p>Book and API documentation - the book is rendered with <code>mdbook</code> and we also
build all documentation with <code>cargo doc</code>.</p>
</li>
</ul>
<p>Artifacts are produced for every single commit and every single PR. You should
be able to find a downloadable version of all artifacts produced on the &quot;runs&quot;
page in GitHub Actions. For example <a href="https://github.com/bytecodealliance/wasmtime/actions/runs/50372673">here's an example
job</a>, and if
you're looking at <a href="https://github.com/bytecodealliance/wasmtime/runs/488719677?check_suite_focus=true">a specific
builder</a>
you can see the artifacts link in the top right. Note that artifacts don't
become available until the whole run finishes.</p>
<p>Commits merged into the <code>main</code> branch will rerun CI and will also produce
artifacts as usual. On the <code>main</code> branch, however, documentation is pushed to
the <code>gh-pages</code> branch as well, and binaries are pushed to the <code>dev</code> release on
GitHub. Finally, tagged commits get a whole dedicated release to them too.</p>
<h1><a class="header" href="#coding-guidelines" id="coding-guidelines">Coding guidelines</a></h1>
<p>For the most part, Wasmtime and Cranelift follow common Rust conventions and
<a href="https://help.github.com/articles/about-pull-requests/">pull request</a> (PR) workflows, though we do have a few additional things to
be aware of.</p>
<h3><a class="header" href="#rustfmt" id="rustfmt"><code>rustfmt</code></a></h3>
<p>All PRs must be formatted according to rustfmt, and this is checked in the
continuous integration tests. You can format code locally with:</p>
<pre><code class="language-sh">$ cargo fmt
</code></pre>
<p>at the root of the repository. You can find <a href="https://github.com/rust-lang/rustfmt">more information about rustfmt
online</a> too, such as how to configure
your editor.</p>
<h3><a class="header" href="#minimum-supported-rustc-version" id="minimum-supported-rustc-version">Minimum Supported <code>rustc</code> Version</a></h3>
<p>Wasmtime supports the current stable version of Rust.</p>
<p>Cranelift supports stable Rust, and follows the <a href="https://wiki.mozilla.org/Rust_Update_Policy_for_Firefox#Schedule">Rust Update Policy for
Firefox</a>.</p>
<p>Some of the developer scripts depend on nightly Rust, for example to run
clippy and other tools, however we avoid depending on these for the main
build.</p>
<h1><a class="header" href="#development-process" id="development-process">Development Process</a></h1>
<p>We use <a href="https://guides.github.com/features/issues/">issues</a> for asking questions (<a href="https://github.com/bytecodealliance/wasmtime/issues/new">open one here</a>!) and tracking
bugs and unimplemented features, and <a href="https://help.github.com/articles/about-pull-requests/">pull requests</a> (PRs) for tracking and
reviewing code submissions.</p>
<h3><a class="header" href="#before-submitting-a-pr" id="before-submitting-a-pr">Before submitting a PR</a></h3>
<p>Consider opening an issue to talk about it. PRs without corresponding issues
are appropriate for fairly narrow technical matters, not for fixes to
user-facing bugs or for feature implementations, especially when those features
might have multiple implementation strategies that usefully could be discussed.</p>
<p>Our issue templates might help you through the process.</p>
<h3><a class="header" href="#when-submitting-prs" id="when-submitting-prs">When submitting PRs</a></h3>
<ul>
<li>
<p>Please fill in the pull request template as appropriate. It is usually
helpful, it speeds up the review process and helps understanding the changes
brought by the PR.</p>
</li>
<li>
<p>Write clear commit messages that start with a one-line summary of the
change (and if it's difficult to summarize in one line, consider
splitting the change into multiple PRs), optionally followed by
additional context. Good things to mention include which areas of the
code are affected, which features are affected, and anything that
reviewers might want to pay special attention to.</p>
</li>
<li>
<p>If there is code which needs explanation, prefer to put the explanation in
a comment in the code, or in documentation, rather than in the commit
message.</p>
</li>
<li>
<p>For pull requests that fix existing issues, use <a href="https://help.github.com/articles/closing-issues-using-keywords/">issue keywords</a>. Note that
not all pull requests need to have accompanying issues.</p>
</li>
<li>
<p>Assign the review to somebody from the <a href="https://github.com/orgs/bytecodealliance/people/">Core Team</a>, either using suggestions
in the list proposed by Github, or somebody else if you have a specific
person in mind.</p>
</li>
<li>
<p>When updating your pull request, please make sure to re-request review if
the request has been cancelled.</p>
</li>
</ul>
<h3><a class="header" href="#focused-commits-or-squashing" id="focused-commits-or-squashing">Focused commits or squashing</a></h3>
<p>We generally squash sequences of incremental-development commits together into
logical commits (though keeping logical commits focused). Developers may do
this themselves before submitting a PR or during the PR process, or Core Team
members may do it when merging a PR. Ideally, the continuous-integration tests
should pass at each logical commit.</p>
<h3><a class="header" href="#review-and-merge" id="review-and-merge">Review and merge</a></h3>
<p>Anyone may submit a pull request, and anyone may comment on or review others'
pull requests. However, one review from somebody in the <a href="https://github.com/orgs/bytecodealliance/people/">Core Team</a> is required
before the Core Team merges it.</p>
<p>Even Core Team members should create PRs for every change, including minor work
items (version bump, removing warnings, etc.): this is helpful to keep track of
what has happened on the repository. Very minor changes may be merged without a
review, although it is always preferred to have one.</p>
<h1><a class="header" href="#release-process-1" id="release-process-1">Release Process</a></h1>
<p>This is intended to serve as documentation for Wasmtime's release process. It's
largely an internal checklist for those of us performing a Wasmtime release, but
others might be curious in this as well!</p>
<p>To kick off the release process someone decides to do a release. Currently
there's not a schedule for releases or something similar. Once the decision is
made (there's also not really a body governing these decisions, it's more
whimsical currently, or on request from others) then the following steps need to
be executed to make the release:</p>
<ol>
<li><code>git pull</code> - make sure you've got the latest changes</li>
<li>Run <code>rustc scripts/publish.rs</code></li>
<li>Run <code>./publish bump</code></li>
</ol>
<ul>
<li>Review and commit the changes</li>
<li>Note that this bumps all cranelift/wasmtime versions as a major version bump
at this time. See the <code>bump_version</code> function in <code>publish.rs</code> to tweak this.</li>
</ul>
<ol>
<li>Make sure <code>RELEASES.md</code> is up-to-date, and fill it out if it doesn't have an
entry yet for the current release.</li>
<li>Send this version update as a PR to the <code>wasmtime</code> repository, wait for a merge</li>
<li>After merging, tag the merge as <code>vA.B.C</code></li>
<li>Push the tag to the repository</li>
</ol>
<ul>
<li>This will trigger the release CI which will create all release artifacts and
publish them to GitHub releases.</li>
</ul>
<ol>
<li>Run <code>./publish publish</code></li>
</ol>
<ul>
<li>This will fail on some crates, but that's expected.</li>
<li>Keep running this script until all crates are published. Note that crates.io
won't let you publish something twice so rerunning is only for crates which
need the index to be udpated and if it hasn't yet. It's recommended to wait
a bit between runs of the script.</li>
</ul>
<p>And that's it, then you've done a Wasmtime release.</p>
<h1><a class="header" href="#implementing-webassembly-proposals" id="implementing-webassembly-proposals">Implementing WebAssembly Proposals</a></h1>
<h2><a class="header" href="#adding-new-support-for-a-wasm-proposal" id="adding-new-support-for-a-wasm-proposal">Adding New Support for a Wasm Proposal</a></h2>
<p>The following checkboxes enumerate the steps required to add support for a new
WebAssembly proposal to Wasmtime. They can be completed over the course of
multiple pull requests.</p>
<ul>
<li>
<p><input type="checkbox"/> Add support to the
<a href="https://github.com/bytecodealliance/wasm-tools/tree/main/crates/wasmparser"><code>wasmparser</code></a>
crate.</p>
</li>
<li>
<p><input type="checkbox"/> Add support to the
<a href="https://github.com/bytecodealliance/wasm-tools/tree/main/crates/wat"><code>wat</code></a>
and
<a href="https://github.com/bytecodealliance/wasm-tools/tree/main/crates/wast"><code>wast</code></a>
crates.</p>
</li>
<li>
<p><input type="checkbox"/> Add support to the
<a href="https://github.com/bytecodealliance/wasm-tools/tree/main/crates/wasmprinter"><code>wasmprinter</code></a>
crate.</p>
</li>
<li>
<p><input type="checkbox"/> Add a <code>wasmtime::Config::enable_foo_bar</code> method to
the <code>wasmtime</code> crate.</p>
</li>
<li>
<p><input type="checkbox"/> Add a <code>--enable-foo-bar</code> command line flag to the
<code>wasmtime</code> binary.</p>
</li>
<li>
<p><input type="checkbox"/> Enable the spec tests in
<a href="https://github.com/bytecodealliance/wasmtime/blob/c7cd70fcec3eee66c9d7b5aa6fb4580d5a802218/build.rs#L41-L52"><code>build.rs</code></a>
but <a href="https://github.com/bytecodealliance/wasmtime/blob/c7cd70fcec3eee66c9d7b5aa6fb4580d5a802218/build.rs#L196">mark them as
ignored</a>
for now.</p>
</li>
<li>
<p><input type="checkbox"/> Stop ignoring individual spec tests and get them
passing one by one.</p>
</li>
<li>
<p><input type="checkbox"/> Enable the proposal in <a href="./contributing-fuzzing.html">the fuzz
targets</a>.</p>
<ul>
<li>
<p><input type="checkbox"/> Add examples from the spec tests to <a href="https://github.com/bytecodealliance/wasmtime-libfuzzer-corpus">the relevant
corpora</a>.</p>
<blockquote>
<p>The <code>wast2json</code> tool from <a href="https://github.com/WebAssembly/wabt/">WABT</a> is useful for this.</p>
</blockquote>
</li>
<li>
<p><input type="checkbox"/> Write a custom fuzz target, oracle, and/or test
case generator for fuzzing this proposal in particular.</p>
<blockquote>
<p>For example, we wrote a <a href="https://github.com/bytecodealliance/wasmtime/blob/c7cd70fcec3eee66c9d7b5aa6fb4580d5a802218/crates/fuzzing/src/generators/table_ops.rs">custom
generator</a>,
<a href="https://github.com/bytecodealliance/wasmtime/blob/c7cd70fcec3eee66c9d7b5aa6fb4580d5a802218/crates/fuzzing/src/oracles.rs#L417-L467">oracle</a>,
and <a href="https://github.com/bytecodealliance/wasmtime/blob/c7cd70fcec3eee66c9d7b5aa6fb4580d5a802218/fuzz/fuzz_targets/table_ops.rs">fuzz
target</a>
for exercising <code>table.{get,set}</code> instructions and their interaction with
GC while implementing the reference types proposal.</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><input type="checkbox"/> Expose the proposal's new functionality in the
<code>wasmtime</code> crate's API.</p>
<blockquote>
<p>For example, the bulk memory operations proposal introduced a <code>table.copy</code>
instruction, and we exposed its functionality as the <code>wasmtime::Table::copy</code>
method.</p>
</blockquote>
</li>
<li>
<p><input type="checkbox"/> Expose the proposal's new functionality in the C API.</p>
<blockquote>
<p>This may require extensions to the standard C API, and if so, should be
defined in
<a href="https://github.com/bytecodealliance/wasmtime/blob/c7cd70fcec3eee66c9d7b5aa6fb4580d5a802218/crates/c-api/include/wasmtime.h"><code>wasmtime.h</code></a>
and prefixed with <code>wasmtime_</code>.</p>
</blockquote>
</li>
<li>
<p><input type="checkbox"/> Use the C API to expose the proposal's new
functionality in the other language embedding APIs:</p>
<ul>
<li>
<p><input type="checkbox"/> <a href="https://github.com/bytecodealliance/wasmtime-py/">Python</a></p>
</li>
<li>
<p><input type="checkbox"/> <a href="https://github.com/bytecodealliance/wasmtime-go/">Go</a></p>
</li>
<li>
<p><input type="checkbox"/> <a href="https://github.com/bytecodealliance/wasmtime-dotnet/">.NET</a></p>
</li>
</ul>
</li>
<li>
<p><input type="checkbox"/> Document support for the proposal in
<code>wasmtime/docs/stability-wasm-proposals-support.md</code>.</p>
</li>
</ul>
<h2><a class="header" href="#enabling-support-for-a-proposal-by-default" id="enabling-support-for-a-proposal-by-default">Enabling Support for a Proposal by Default</a></h2>
<p>These are the standards that must be met to enable support for a proposal by
default in Wasmtime, and can be used as a review checklist.</p>
<ul>
<li>
<p><input type="checkbox"/> The proposal must be in phase 4, or greater, of <a href="https://github.com/WebAssembly/meetings/blob/master/process/phases.md">the
WebAssembly standardization process</a>.</p>
</li>
<li>
<p><input type="checkbox"/> All spec tests must be passing in Wasmtime.</p>
</li>
<li>
<p><input type="checkbox"/> No open questions, design concerns, or serious known
bugs.</p>
</li>
<li>
<p><input type="checkbox"/> Has been fuzzed for at least a week minimum.</p>
</li>
<li>
<p><input type="checkbox"/> We are confident that the fuzzers are fully
exercising the proposal's functionality.</p>
<blockquote>
<p>For example, it would <em>not</em> have been enough to simply enable reference
types in the <code>compile</code> fuzz target to enable that proposal by
default. Compiling a module that uses reference types but not instantiating
it nor running any of its functions doesn't exercise any of the GC
implementation and does not run the inline fast paths for <code>table</code> operations
emitted by the JIT. Exercising these things was the motivation for writing
the custom fuzz target for <code>table.{get,set}</code> instructions.</p>
</blockquote>
</li>
<li>
<p><input type="checkbox"/> The proposal's functionality is exposed in the
<code>wasmtime</code> crate's API.</p>
</li>
<li>
<p><input type="checkbox"/> The proposal's functionality is exposed in the C API.</p>
</li>
<li>
<p><input type="checkbox"/> The proposal's functionality is exposed in at least
one of the other languages' APIs.</p>
</li>
</ul>
<h1><a class="header" href="#governance" id="governance">Governance</a></h1>
<p>... more coming soon</p>
<h1><a class="header" href="#contributor-covenant-code-of-conduct" id="contributor-covenant-code-of-conduct">Contributor Covenant Code of Conduct</a></h1>
<p><em>Note</em>: this Code of Conduct pertains to individuals' behavior. Please also see the <a href="https://github.com/bytecodealliance/wasmtime/blob/main/ORG_CODE_OF_CONDUCT.md">Organizational Code of Conduct</a>.</p>
<h2><a class="header" href="#our-pledge" id="our-pledge">Our Pledge</a></h2>
<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>
<h2><a class="header" href="#our-standards" id="our-standards">Our Standards</a></h2>
<p>Examples of behavior that contributes to creating a positive environment include:</p>
<ul>
<li>Using welcoming and inclusive language</li>
<li>Being respectful of differing viewpoints and experiences</li>
<li>Gracefully accepting constructive criticism</li>
<li>Focusing on what is best for the community</li>
<li>Showing empathy towards other community members</li>
</ul>
<p>Examples of unacceptable behavior by participants include:</p>
<ul>
<li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li>
<li>Trolling, insulting/derogatory comments, and personal or political attacks</li>
<li>Public or private harassment</li>
<li>Publishing others' private information, such as a physical or electronic address, without explicit permission</li>
<li>Other conduct which could reasonably be considered inappropriate in a professional setting</li>
</ul>
<h2><a class="header" href="#our-responsibilities" id="our-responsibilities">Our Responsibilities</a></h2>
<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p>
<p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>
<h2><a class="header" href="#scope" id="scope">Scope</a></h2>
<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>
<h2><a class="header" href="#enforcement" id="enforcement">Enforcement</a></h2>
<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the Bytecode Alliance CoC team at <a href="mailto:report@bytecodealliance.org">report@bytecodealliance.org</a>. The CoC team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The CoC team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p>
<p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the Bytecode Alliance's leadership.</p>
<h2><a class="header" href="#attribution" id="attribution">Attribution</a></h2>
<p>This Code of Conduct is adapted from the <a href="https://www.contributor-covenant.org">Contributor Covenant</a>, version 1.4, available at <a href="https://www.contributor-covenant.org/version/1/4/">http://contributor-covenant.org/version/1/4</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
