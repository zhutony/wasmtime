initSidebarItems({"enum":[["RecipePrefixKind","Specifies how the prefix (e.g. REX) is emitted by a Recipe."]],"fn":[["decode_opcodes","Given a sequence of opcode bytes, compute the recipe name prefix and encoding bits."],["define",""],["replace_evex_constraints",""],["replace_nonrex_constraints","Replaces constraints to a REX-prefixed register class by the equivalent non-REX register class."],["replace_put_op","Given a snippet of Rust code (or None), replace the `PUT_OP` macro with the corresponding `put_*` function from the `binemit.rs` module."],["supported_floatccs_predicate","Returns a predicate checking that the \"cond\" field of the instruction contains one of the directly supported floating point condition codes."],["valid_scale","Return an instruction predicate that checks if `iform.imm` is a valid `scale` for a SIB byte."]],"struct":[["RecipeGroup","Helper data structure to create recipes and template recipes. It contains all the recipes and recipe templates that might be used in the encodings crate of this same directory."],["Template","Previously called a TailRecipe in the Python meta language, this allows to create multiple variants of a single base EncodingRecipe (rex prefix, specialized w/rrr bits, different opcodes). It serves as a prototype of an EncodingRecipe, which is then used when actually creating Encodings, in encodings.rs. This is an idiosyncrasy of the x86 meta-language, and could be reconsidered later."]]});